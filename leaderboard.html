<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of the Week Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        :root {
            /* Primary */
            --primary-0: #303E45;
            --primary-1: #63747C;
            --primary-2: #485962;
            --primary-3: #1C2C34;
            --primary-4: #10232D;

            /* Secondary #1 */
            --secondary1-0: #36394B;
            --secondary1-1: #6E7187;
            --secondary1-2: #50536A;
            --secondary1-3: #212338;
            --secondary1-4: #141831;

            /* Secondary #2 (warm accents) */
            --secondary2-0: #6D634A;
            --secondary2-1: #C4B99B;
            --secondary2-2: #9A8E6F;
            --secondary2-3: #52472A;
            --secondary2-4: #473A17;

            /* Complement */
            --complement-0: #6D5D4A;
            --complement-1: #C4B19B;
            --complement-2: #9A866F;
            --complement-3: #523F2A;
            --complement-4: #473117;

            /* Convenience variables */
            --bg: var(--primary-4);
            --surface: var(--primary-0);
            --muted: var(--secondary1-2);
            --accent: var(--secondary2-1);
            --accent-dark: var(--secondary2-3);
            --text-on-dark: #ffffff;
            --text-on-light: #111111;

            /* Legacy MCC brand colors (for backward compatibility) */
            --mcc-blue-gray: #607d8b;
            --mcc-dark-1: #57707d;
            --mcc-dark-2: #4d636f;
            --mcc-light-1: #dfe5e8;
            --mcc-light-2: #becbd2;
            --mcc-gold-1: #ab9000;
            --mcc-gold-2: #8a7500;

            /* Semantic colors */
            --success: #4CAF50;
            --success-hover: #45a049;
            --success-dark: #2e7d32;
            --success-light: #c8e6c9;
            --success-bg: #f0f9f0;
            --error: #f44336;
            --error-dark: #c62828;
            --error-light: #ffcdd2;
            --error-bg: #ffebee;
            --warning: #ff9800;
            --info: #3498db;

            /* Medal colors */
            --gold: #FFD700;
            --silver: #C0C0C0;
            --bronze: #CD7F32;

            /* Neutral grays */
            --gray-50: #f8f9fa;
            --gray-100: #f5f5f5;
            --gray-200: #e8e8e8;
            --gray-300: #ddd;
            --gray-400: #999;
            --gray-500: #666;
            --gray-600: #555;
            --gray-700: #333;
            --gray-neutral: #95a5a6;

            /* Text colors */
            --text-primary: #333;
            --text-secondary: #666;
            --text-muted: #999;
            --text-disabled: #ccc;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--gray-100);
            margin: 0;
            padding: 20px;
        }

        .dashboard-container {
            max-width: 1600px;
            margin: auto;
        }

        .dashboard-header {
            text-align: center;
            padding: 20px 20px 20px;
        }

        .header-content {
            position: relative;
            display: inline-block;
            margin: 0 auto;
        }

        .header-goblet {
            width: 160px;
            height: 160px;
            display: block;
            margin: 0 auto;
        }

        .header-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .header-text h1 {
            font-size: 42px;
            color: var(--text-primary);
            margin: 0;
            font-weight: 700;
            text-shadow:
                -2px -2px 0 #fff,
                2px -2px 0 #fff,
                -2px 2px 0 #fff,
                2px 2px 0 #fff,
                0 0 8px rgba(255, 255, 255, 0.8);
        }

        .header-text .subtitle {
            font-size: 14px;
            color: var(--mcc-blue-gray);
            margin-top: 3px;
            font-weight: 600;
            text-shadow:
                -1px -1px 0 #fff,
                1px -1px 0 #fff,
                -1px 1px 0 #fff,
                1px 1px 0 #fff,
                0 0 4px rgba(255, 255, 255, 0.9);
        }

        .league-link {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 14px;
            z-index: 1000;
        }

        body {
            position: relative;
        }

        .league-link a {
            color: var(--mcc-blue-gray);
            text-decoration: none;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .league-link a:hover {
            color: var(--mcc-dark-2);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            background-color: rgba(255, 255, 255, 1);
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            align-items: start;
        }

        @media (min-width: 1200px) {
            .dashboard-grid {
                grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            }
        }

        @media (min-width: 1600px) {
            .dashboard-grid {
                grid-template-columns: minmax(0, 45fr) minmax(0, 55fr);
            }
        }

        .left-column-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 0; /* Allow flex items to shrink below content size */
            max-width: 100%; /* Prevent expansion beyond grid column */
        }

        .right-column-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 20px;
            border-bottom: 3px solid var(--success);
            padding-bottom: 10px;
        }

        .leaderboard-container {
            /* Grid item - no need for max-width now */
        }

        /* Horse Race Styles */
        #horseRaceChart {
            width: 100%;
            height: 450px;
            display: block;
        }

        @media (max-width: 1199px) {
            #horseRaceChart {
                height: 400px;
            }
        }

        .horse-race-line {
            fill: none;
            stroke-width: 2.5px;
            transition: stroke-width 0.2s;
        }

        .horse-race-line.highlighted {
            stroke-width: 5px !important;
            stroke: #000 !important;
        }

        .horse-race-dot {
            fill: white;
            stroke-width: 2px;
        }

        .race-legend {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .race-legend-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .race-legend-item:hover {
            background-color: var(--gray-100);
        }

        .race-legend-item.hidden {
            opacity: 0.4;
        }

        .race-legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .race-legend-name {
            font-size: 13px;
            color: var(--text-primary);
            flex-grow: 1;
        }

        .race-legend-record {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 5px;
        }

        .race-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .race-btn {
            padding: 8px 16px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            background-color: var(--gray-100);
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .race-btn:hover {
            background-color: var(--gray-200);
        }

        th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s;
        }

        th.sortable:hover {
            background-color: var(--gray-200);
        }

        th.sortable::after {
            content: '';
            margin-left: 6px;
            opacity: 0.3;
        }

        th.sortable.sorted-asc::after {
            content: '▲';
            opacity: 1;
        }

        th.sortable.sorted-desc::after {
            content: '▼';
            opacity: 1;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        @media (min-width: 768px) {
            .stats-summary {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (min-width: 1200px) {
            .stats-summary {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .stat-card {
            background-color: var(--gray-50);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--success);
        }

        .stat-card .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .stat-card .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--gray-50);
            border-radius: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-group.checkbox-group {
            gap: 6px;
        }

        .filter-group label {
            font-size: 14px;
            color: var(--gray-600);
            font-weight: 500;
        }

        .filter-group select {
            padding: 8px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
            min-width: 150px;
        }

        .filter-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .filter-btn {
            padding: 8px 16px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            background-color: var(--error);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            margin-left: auto;
        }

        .filter-btn:hover {
            background-color: var(--error-dark);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        thead {
            background-color: var(--gray-50);
            position: sticky;
            top: 0;
        }

        th {
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            color: var(--gray-600);
            border-bottom: 2px solid var(--gray-300);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        th.center, td.center {
            text-align: center;
        }

        th.right, td.right {
            text-align: right;
        }

        tbody tr {
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }

        tbody tr:hover {
            background-color: var(--gray-50);
        }

        td {
            padding: 15px 10px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .rank {
            font-weight: bold;
            color: var(--text-secondary);
            font-size: 16px;
        }

        .rank.gold {
            color: var(--gold);
        }

        .rank.silver {
            color: var(--silver);
        }

        .rank.bronze {
            color: var(--bronze);
        }

        .player-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 15px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .player-name:hover {
            color: var(--success);
            text-decoration: underline;
        }

        .player-name .picks-icon {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: 6px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .player-name:hover .picks-icon {
            opacity: 1;
            color: var(--success);
        }

        .win-percentage {
            font-weight: 600;
        }

        .win-percentage.high {
            color: var(--success);
        }

        .win-percentage.medium {
            color: var(--warning);
        }

        .win-percentage.low {
            color: var(--error);
        }

        .recent-form {
            display: flex;
            gap: 3px;
            justify-content: center;
        }

        .form-indicator {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            display: inline-block;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 20px;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
        }

        .form-indicator:hover {
            opacity: 0.8;
            transform: scale(1.1);
        }

        .form-indicator.win {
            background-color: var(--success);
        }

        .form-indicator.loss {
            background-color: var(--error);
        }

        .form-indicator.no-game {
            background-color: var(--gray-200);
        }

        .expand-header-btn {
            cursor: pointer;
            color: var(--success);
            font-weight: bold;
            font-size: 18px;
            margin-left: 8px;
            user-select: none;
            transition: transform 0.3s;
            display: inline-block;
        }

        .expand-header-btn:hover {
            color: var(--success-hover);
        }

        .expand-header-btn.expanded {
            transform: rotate(90deg);
        }

        th.game-history-header {
            cursor: pointer;
            min-width: 150px;
        }

        .game-history-cell {
            transition: all 0.3s ease;
        }

        .game-history-cell.collapsed .recent-form {
            display: flex;
            gap: 3px;
            justify-content: center;
            flex-wrap: nowrap;
        }

        .game-history-cell.expanded .recent-form {
            display: flex;
            gap: 3px;
            justify-content: flex-start;
            flex-wrap: wrap;
            max-width: 800px;
            padding: 5px;
        }

        tbody tr:hover .game-history-cell {
            background-color: var(--gray-50);
        }

        .tooltip {
            position: absolute;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            display: none;
            z-index: 2000;
            min-width: 400px;
            max-width: 500px;
        }

        #raceTooltip {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 5px;
            font-size: 13px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 200px;
        }

        /* Upcoming Matchups Styles */
        .upcoming-section {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #dfe5e815 0%, #becbd215 100%);
            border: 2px solid var(--mcc-blue-gray);
        }

        .expand-schedule-container {
            text-align: center;
            margin-top: 20px;
        }

        .expand-schedule-btn {
            padding: 6px 16px;
            border: 1px solid var(--silver);
            border-radius: 6px;
            background-color: white;
            color: var(--gray-400);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .expand-schedule-btn:hover {
            background-color: var(--gray-100);
            color: var(--mcc-blue-gray);
            border-color: var(--mcc-blue-gray);
        }

        #expandScheduleIcon {
            transition: transform 0.3s;
            font-size: 12px;
        }

        .expand-schedule-btn.expanded #expandScheduleIcon {
            transform: rotate(180deg);
        }


        /* Centered single-column layout for upcoming matchups */
        .upcoming-section .matchups-grid {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        /* Upcoming Matchup Card Styles */
        .upcoming-matchup-card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            width: 100%;
            max-width: 1000px;
        }

        .upcoming-matchup-header {
            background: linear-gradient(135deg, var(--mcc-dark-1) 0%, var(--mcc-dark-2) 100%);
            color: white;
            padding: 10px 15px;
            text-align: center;
        }

        .upcoming-matchup-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .upcoming-matchup-info {
            font-size: 12px;
            opacity: 0.95;
        }

        .upcoming-matchup-body {
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }

        .upcoming-team-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .upcoming-team-name {
            font-size: 15px;
            font-weight: bold;
            color: var(--text-primary);
            text-align: center;
        }

        .upcoming-members-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .upcoming-vs-divider {
            text-align: center;
            color: var(--mcc-dark-1);
            font-size: 24px;
            font-weight: bold;
            flex-shrink: 0;
            padding: 20px;
            position: relative;
            min-width: 80px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow:
                -1px -1px 0 #fff,
                1px -1px 0 #fff,
                -1px 1px 0 #fff,
                1px 1px 0 #fff,
                0 0 3px #fff,
                0 0 5px rgba(255, 255, 255, 0.8);
        }

        .upcoming-vs-divider::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('handshake.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.07;
        }

        /* Schedule Styles */
        .schedule-section {
            margin-top: 20px;
        }

        .schedule-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .schedule-filter-btn {
            padding: 8px 16px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            background-color: var(--gray-100);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .schedule-filter-btn:hover {
            background-color: var(--gray-200);
        }

        .schedule-filter-btn.active {
            background-color: var(--success);
            color: white;
            border-color: var(--success-hover);
        }

        .matchups-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        /* Week group styles */
        .week-group {
            margin-top: 30px;
            padding-top: 25px;
            width: 100%;
            border-top: 1px solid #dfe5e8;
        }

        .week-group:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        .week-header {
            color: var(--mcc-blue-gray);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
        }

        .week-games {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
        }

        /* Override grid for full schedule container to allow week grouping */
        #matchupsGrid {
            display: block;
        }

        .matchup-card {
            background-color: var(--gray-50);
            border-radius: 8px;
            padding: 12px 15px;
            border: 2px solid var(--gray-200);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .matchup-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.12);
            border-color: var(--success);
        }

        .matchup-card.completed {
            border-color: var(--success);
            background-color: var(--success-bg);
        }

        .matchup-compact-header {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-align: center;
        }

        .matchup-compact-teams {
            font-size: 14px;
            text-align: center;
            color: var(--text-primary);
        }

        .compact-vs {
            color: var(--text-muted);
            font-weight: normal;
            margin: 0 8px;
        }

        .matchup-teams {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .matchup-team {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background-color: white;
            border-radius: 5px;
            transition: background-color 0.2s;
        }

        .matchup-team.winner {
            background-color: var(--success);
            color: white;
            font-weight: bold;
        }

        .matchup-team-name {
            flex-grow: 1;
        }

        .matchup-vs {
            text-align: center;
            font-size: 12px;
            color: var(--text-muted);
            margin: 3px 0;
        }

        .winner-badge {
            background-color: white;
            color: var(--success);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
        }

        /* Matchup Tooltip with Team Lineups */
        #matchupTooltip {
            position: absolute;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            display: none;
            z-index: 2000;
            min-width: 400px;
            max-width: 500px;
        }

        .matchup-tooltip-header {
            background: linear-gradient(135deg, var(--mcc-dark-1) 0%, var(--mcc-dark-2) 100%);
            color: white;
            padding: 15px;
            border-radius: 10px 10px 0 0;
            text-align: center;
        }

        .matchup-tooltip-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .matchup-tooltip-info {
            font-size: 12px;
            opacity: 0.9;
        }

        .matchup-tooltip-body {
            padding: 15px;
        }

        .tooltip-team-section {
            margin-bottom: 20px;
        }

        .tooltip-team-section:last-child {
            margin-bottom: 0;
        }

        .tooltip-team-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-primary);
            text-align: center;
        }

        .tooltip-team-name.winner {
            color: var(--success);
        }

        .tooltip-members-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .tooltip-member {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .tooltip-avatar-wrapper {
            position: relative;
        }

        .tooltip-avatar {
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border-style: solid;
        }

        .tooltip-member:not(.skip-member) .tooltip-avatar {
            width: 45px;
            height: 45px;
            border-width: 2px;
        }

        .tooltip-member.skip-member .tooltip-avatar {
            width: 55px;
            height: 55px;
            border-width: 3px;
        }

        .tooltip-avatar-sprite {
            border-radius: 50%;
            background-image: url('mcc_integration/generic_avatar_sprite.png');
            background-size: 500%;
            background-repeat: no-repeat;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border-style: solid;
        }

        .tooltip-member:not(.skip-member) .tooltip-avatar-sprite {
            width: 45px;
            height: 45px;
            border-width: 2px;
        }

        .tooltip-member.skip-member .tooltip-avatar-sprite {
            width: 55px;
            height: 55px;
            border-width: 3px;
        }

        .tooltip-avatar-placeholder {
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border-style: solid;
        }

        .tooltip-member:not(.skip-member) .tooltip-avatar-placeholder {
            width: 45px;
            height: 45px;
            font-size: 16px;
            border-width: 2px;
        }

        .tooltip-member.skip-member .tooltip-avatar-placeholder {
            width: 55px;
            height: 55px;
            font-size: 20px;
            border-width: 3px;
        }

        /* Position-specific avatar colors for tooltip */
        .tooltip-avatar.position-skip,
        .tooltip-avatar-sprite.position-skip {
            border-color: #ffd700;
        }

        .tooltip-avatar-placeholder.position-skip {
            border-color: #ffd700;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
        }

        .tooltip-avatar.position-vice,
        .tooltip-avatar-sprite.position-vice {
            border-color: #c0c0c0;
        }

        .tooltip-avatar-placeholder.position-vice {
            border-color: #c0c0c0;
            background: linear-gradient(135deg, #c0c0c0 0%, #e0e0e0 100%);
            color: #333;
        }

        .tooltip-avatar.position-second,
        .tooltip-avatar-sprite.position-second {
            border-color: #cd7f32;
        }

        .tooltip-avatar-placeholder.position-second {
            border-color: #cd7f32;
            background: linear-gradient(135deg, #cd7f32 0%, #e8a864 100%);
            color: #fff;
        }

        .tooltip-avatar.position-lead,
        .tooltip-avatar-sprite.position-lead {
            border-color: #3498db;
        }

        .tooltip-avatar-placeholder.position-lead {
            border-color: #3498db;
            background: linear-gradient(135deg, #3498db 0%, #5dade2 100%);
            color: #fff;
        }

        .tooltip-avatar.position-fifth,
        .tooltip-avatar-sprite.position-fifth {
            border-color: #95a5a6;
        }

        .tooltip-avatar-placeholder.position-fifth {
            border-color: #95a5a6;
            background: linear-gradient(135deg, #95a5a6 0%, #bdc3c7 100%);
            color: #fff;
        }

        .tooltip-member-name {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
        }

        .tooltip-position-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .tooltip-position-badge.position-skip {
            background-color: var(--gold);
            color: #000;
        }

        .tooltip-position-badge.position-vice {
            background-color: var(--silver);
            color: #000;
        }

        .tooltip-position-badge.position-second {
            background-color: var(--bronze);
            color: #fff;
        }

        .tooltip-position-badge.position-lead {
            background-color: var(--info);
            color: #fff;
        }

        .tooltip-position-badge.position-fifth {
            background-color: var(--gray-neutral);
            color: #fff;
        }

        .tooltip-vs-divider {
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            font-weight: bold;
            margin: 10px 0;
        }

        /* Right Column Container */
        /* What-If Analysis Styles */
        .whatif-section {
            margin-top: 0;
        }

        .whatif-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .whatif-summary {
            background-color: var(--gray-50);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .whatif-summary-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .whatif-summary-text strong {
            color: var(--text-primary);
            font-size: 16px;
        }

        .whatif-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }

        @media (max-width: 1200px) {
            .whatif-content {
                grid-template-columns: 1fr;
            }
        }

        .whatif-column {
            display: flex;
            flex-direction: column;
        }

        .whatif-column-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--gray-200);
        }

        .upcoming-games-container {
            margin-bottom: 20px;
        }

        .whatif-player-picker {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .whatif-player-picker label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .whatif-player-picker select {
            padding: 8px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
        }

        .whatif-btn {
            padding: 8px 16px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            background-color: var(--success);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .whatif-btn:hover {
            background-color: var(--success-hover);
        }

        .whatif-btn.secondary {
            background-color: var(--gray-100);
            color: var(--text-primary);
        }

        .whatif-btn.secondary:hover {
            background-color: var(--gray-200);
        }

        .upcoming-games {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 600px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .upcoming-games::-webkit-scrollbar {
            width: 8px;
        }

        .upcoming-games::-webkit-scrollbar-track {
            background: var(--gray-100);
            border-radius: 4px;
        }

        .upcoming-games::-webkit-scrollbar-thumb {
            background: var(--gray-400);
            border-radius: 4px;
        }

        .upcoming-games::-webkit-scrollbar-thumb:hover {
            background: var(--gray-600);
        }

        .game-card {
            background-color: var(--gray-50);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--gray-200);
        }

        .game-card-header {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .game-matchup {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .team-option {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 2px solid transparent;
        }

        .team-option:hover {
            background-color: var(--gray-200);
        }

        .team-option.selected {
            background-color: var(--success);
            color: white;
            border-color: var(--success-hover);
        }

        .team-option.chalk {
            border-color: var(--warning);
        }

        .team-option input[type="radio"] {
            margin-right: 10px;
        }

        .team-name {
            flex-grow: 1;
        }

        .pick-count {
            font-size: 11px;
            opacity: 0.8;
        }

        .whatif-results {
            display: flex;
            flex-direction: column;
        }

        .whatif-results h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-primary);
            font-size: 20px;
        }

        .standings-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .standings-toggle-btn {
            padding: 8px 16px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            background-color: var(--gray-100);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            flex: 1;
        }

        .standings-toggle-btn:hover {
            background-color: var(--gray-200);
        }

        .standings-toggle-btn.active {
            background-color: var(--success);
            color: white;
            border-color: var(--success-hover);
        }

        .standings-view {
            display: none;
            max-height: 600px;
            overflow-y: auto;
        }

        .standings-view.active {
            display: block;
        }

        .standings-view::-webkit-scrollbar {
            width: 8px;
        }

        .standings-view::-webkit-scrollbar-track {
            background: var(--gray-100);
            border-radius: 4px;
        }

        .standings-view::-webkit-scrollbar-thumb {
            background: var(--gray-400);
            border-radius: 4px;
        }

        .standings-view::-webkit-scrollbar-thumb:hover {
            background: var(--gray-600);
        }

        .whatif-placeholder {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
            background-color: var(--gray-50);
            border-radius: 8px;
            border: 2px dashed var(--gray-300);
        }

        .whatif-placeholder-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .whatif-placeholder-text {
            font-size: 14px;
        }

        .comparison-table {
            width: 100%;
        }

        .comparison-table th {
            background-color: var(--gray-50);
        }

        .rank-change {
            font-size: 12px;
            font-weight: bold;
            margin-left: 8px;
        }

        .rank-change.up {
            color: var(--success);
        }

        .rank-change.down {
            color: var(--error);
        }

        .rank-change.same {
            color: var(--text-muted);
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 16px;
            color: var(--text-secondary);
        }

        .error {
            background-color: var(--error-bg);
            color: var(--error-dark);
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid var(--error-dark);
        }

        @media (max-width: 768px) {
            .leaderboard-container {
                padding: 15px;
            }

            table {
                font-size: 12px;
            }

            th, td {
                padding: 10px 5px;
            }

            .header h1 {
                font-size: 24px;
            }

            .form-indicator {
                width: 16px;
                height: 16px;
                line-height: 16px;
                font-size: 10px;
            }
        }

        /* Player Details Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, var(--mcc-dark-1) 0%, var(--mcc-dark-2) 100%);
            color: white;
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            margin: 0;
        }

        .modal-subtitle {
            font-size: 14px;
            opacity: 0.9;
            margin-top: 5px;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 24px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .modal-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
        }

        .picks-list {
            display: grid;
            gap: 12px;
        }

        .pick-item {
            background-color: var(--gray-50);
            border-radius: 8px;
            padding: 15px;
            display: grid;
            grid-template-columns: 80px 1fr auto;
            gap: 15px;
            align-items: center;
            border: 2px solid var(--gray-200);
            transition: all 0.2s;
        }

        .pick-item:hover {
            border-color: var(--success);
            background-color: var(--success-bg);
        }

        .pick-item.pick-win {
            border-left: 5px solid var(--success);
        }

        .pick-item.pick-loss {
            border-left: 5px solid var(--error);
        }

        .pick-item.pick-pending {
            border-left: 5px solid var(--text-muted);
        }

        .pick-game-number {
            font-weight: bold;
            font-size: 16px;
            color: var(--text-secondary);
            text-align: center;
        }

        .pick-details {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .pick-matchup {
            font-size: 14px;
            color: var(--text-primary);
        }

        .pick-matchup-teams {
            font-weight: 600;
            color: var(--text-primary);
        }

        .pick-info {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .pick-choice {
            font-size: 13px;
        }

        .pick-choice-label {
            color: var(--text-secondary);
        }

        .pick-choice-team {
            font-weight: 600;
            color: var(--success);
        }

        .pick-contrarian {
            background-color: var(--warning);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 8px;
        }

        .pick-result {
            text-align: center;
            min-width: 60px;
        }

        .pick-result-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 14px;
        }

        .pick-result-badge.win {
            background-color: var(--success);
            color: white;
        }

        .pick-result-badge.loss {
            background-color: var(--error);
            color: white;
        }

        .pick-result-badge.pending {
            background-color: var(--gray-200);
            color: var(--text-secondary);
        }

        /* Combined Picks View */
        .picks-view-section {
            margin-top: 20px;
            min-width: 0; /* Allow section to shrink */
            overflow: hidden; /* Prevent content from expanding section */
        }

        .picks-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .picks-view-header .section-title {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .picks-view-toggle {
            display: flex;
            gap: 10px;
            background-color: var(--gray-50);
            padding: 5px;
            border-radius: 8px;
        }

        .picks-toggle-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .picks-toggle-btn:hover {
            background-color: var(--gray-200);
            color: var(--text-primary);
        }

        .picks-toggle-btn.active {
            background-color: var(--mcc-blue-gray);
            color: white;
        }

        .picks-view-content {
            min-width: 0; /* Allow content to shrink */
            max-width: 100%; /* Prevent expansion */
        }

        .matrix-filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--gray-50);
            border-radius: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .matrix-filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .matrix-filter-group label {
            font-size: 14px;
            color: var(--gray-600);
            font-weight: 500;
        }

        .matrix-filter-group select {
            padding: 8px 12px;
            border: 1px solid var(--gray-300);
            border-radius: 5px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
        }

        .picks-matrix-container {
            overflow-x: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            width: 100%;
        }

        .picks-matrix-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .picks-matrix-table thead {
            background-color: var(--gray-50);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .picks-matrix-table th {
            padding: 10px 8px;
            text-align: center;
            font-weight: 600;
            color: var(--gray-600);
            border: 1px solid var(--gray-300);
            font-size: 11px;
            min-width: 140px;
        }

        .matrix-header-pie {
            width: 50px;
            height: 50px;
            margin: 8px auto;
            cursor: pointer;
            position: relative;
        }

        .matrix-header-pie:hover {
            opacity: 0.8;
        }

        .matrix-header-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .matrix-header-info {
            text-align: center;
        }

        .pie-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1000;
            display: none;
        }

        .pie-tooltip.active {
            display: block;
        }

        .picks-matrix-table th.player-col {
            position: sticky;
            left: 0;
            background-color: var(--gray-50);
            z-index: 11;
            min-width: 150px;
            text-align: left;
        }

        .picks-matrix-table td {
            padding: 8px;
            text-align: center;
            border: 1px solid var(--gray-300);
            font-size: 12px;
        }

        .picks-matrix-table td.player-col {
            position: sticky;
            left: 0;
            background-color: white;
            font-weight: 600;
            text-align: left;
            z-index: 5;
        }

        .picks-matrix-table tbody tr:hover td {
            background-color: var(--gray-50);
        }

        .picks-matrix-table tbody tr:hover td.player-col {
            background-color: var(--gray-200);
        }

        .matrix-pick-cell {
            padding: 4px;
            border-radius: 4px;
            font-size: 11px;
            line-height: 1.3;
        }

        .matrix-pick-cell.win {
            background-color: var(--success-light);
            color: var(--success-dark);
            font-weight: 600;
        }

        .matrix-pick-cell.loss {
            background-color: var(--error-light);
            color: var(--error-dark);
            font-weight: 600;
        }

        .matrix-pick-cell.pending {
            background-color: var(--gray-100);
            color: var(--text-secondary);
        }

        .matrix-pick-cell.contrarian {
            border: 2px solid var(--warning);
        }

        .week-header-cell {
            background-color: var(--mcc-blue-gray) !important;
            color: white !important;
            font-weight: bold;
            font-size: 12px;
        }

        /* Pick Distribution Chart */
        .distribution-list {
            display: grid;
            gap: 15px;
        }

        .distribution-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .distribution-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        .distribution-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .distribution-game-info {
            font-size: 13px;
            color: #666;
        }

        .distribution-matchup {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .distribution-bar-container {
            display: flex;
            height: 40px;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .distribution-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            color: white;
            transition: all 0.3s;
            position: relative;
        }

        .distribution-bar.team1 {
            background: linear-gradient(135deg, var(--mcc-dark-1) 0%, var(--mcc-dark-2) 100%);
        }

        .distribution-bar.team2 {
            background: linear-gradient(135deg, var(--mcc-gold-1) 0%, var(--mcc-gold-2) 100%);
        }

        .distribution-bar:hover {
            filter: brightness(1.1);
        }

        .distribution-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 13px;
        }

        .distribution-label {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .distribution-label-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .distribution-label-color.team1 {
            background: linear-gradient(135deg, var(--mcc-dark-1) 0%, var(--mcc-dark-2) 100%);
        }

        .distribution-label-color.team2 {
            background: linear-gradient(135deg, var(--mcc-gold-1) 0%, var(--mcc-gold-2) 100%);
        }

        .distribution-label-text {
            color: var(--text-primary);
            font-weight: 500;
        }

        .distribution-label-count {
            color: var(--text-secondary);
            font-size: 12px;
        }

        .distribution-winner-badge {
            background-color: var(--gold);
            color: var(--text-primary);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
    </style>
</head>
<body>
    <!-- MCC Member Page Link (Upper Right) -->
    <div class="league-link">
        <a href="https://curlingmembers.com/Members/LeagueDetail.aspx?id=604" target="_blank" rel="noopener noreferrer">
            MCC Member Page <i class="fas fa-external-link-alt"></i>
        </a>
    </div>

    <div class="dashboard-container">
        <!-- Main Header -->
        <div class="dashboard-header">
            <div class="header-content">
                <img src="Goblet.png" alt="Trophy" class="header-goblet">
                <div class="header-text">
                    <h1>Game of the Week</h1>
                    <div class="subtitle">2025-2026 Season</div>
                </div>
            </div>
        </div>

        <div id="loadingMessage" class="loading">Loading dashboard data...</div>
        <div id="errorMessage" class="error" style="display: none;"></div>

        <!-- Dashboard Grid -->
        <div class="dashboard-grid" id="dashboardGrid" style="display: none;">

            <!-- Upcoming Matchups Section -->
            <section class="section upcoming-section">
                <h2 class="section-title"><i class="fas fa-fire"></i> Upcoming Matchup(s)</h2>
                <div class="matchups-grid" id="upcomingMatchupsGrid"></div>
                <div class="expand-schedule-container">
                    <button class="expand-schedule-btn" id="expandScheduleBtn">
                        <span id="expandScheduleText">Show Full Schedule</span>
                        <span id="expandScheduleIcon">▼</span>
                    </button>
                </div>

                <!-- Full Schedule Section (Initially Hidden) -->
                <div class="schedule-section" id="fullScheduleSection" style="display: none;">
                    <h2 class="section-title"><i class="fas fa-calendar"></i> Full Game Schedule</h2>

                    <div class="schedule-filters">
                        <button class="schedule-filter-btn active" data-filter="all">All Games</button>
                        <button class="schedule-filter-btn" data-filter="completed">Completed</button>
                        <button class="schedule-filter-btn" data-filter="upcoming">Upcoming</button>
                    </div>

                    <div class="matchups-grid" id="matchupsGrid"></div>
                </div>
            </section>

            <!-- Left Column Container -->
            <div class="left-column-container">
                <!-- Leaderboard Section -->
                <section class="section leaderboard-section">
                    <h2 class="section-title"><i class="fas fa-medal"></i> Current Standings</h2>

                    <div class="stats-summary" id="statsSummary"></div>

                    <!-- Filter Controls -->
                    <div class="filter-controls">
                        <div class="filter-group">
                            <label for="teamFilter">Team:</label>
                            <select id="teamFilter">
                                <option value="">All Teams</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="positionFilter">Position:</label>
                            <select id="positionFilter">
                                <option value="">All Positions</option>
                            </select>
                        </div>
                        <div class="filter-group checkbox-group">
                            <input type="checkbox" id="funkEngFilter">
                            <label for="funkEngFilter">Funk-Eng Challengers Only (Lead/Second)</label>
                        </div>
                        <button class="filter-btn" id="resetFilters">Reset Filters</button>
                    </div>

                    <table id="leaderboardTable">
                <thead>
                    <tr>
                        <th class="center sortable sorted-asc" data-sort="rank">Rank</th>
                        <th class="sortable" data-sort="name">Player</th>
                        <th class="center sortable" data-sort="wins">Wins</th>
                        <th class="center sortable" data-sort="losses">Losses</th>
                        <th class="center sortable" data-sort="winPct">Win %</th>
                        <th class="center game-history-header" id="gameHistoryHeader">
                            <span id="gameHistoryLabel">Recent Form</span>
                            <span class="expand-header-btn" id="expandHeaderBtn" title="Expand to show all games">▶</span>
                        </th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody">
                        </tbody>
                    </table>
                    <div class="tooltip" id="tooltip"></div>
                </section>

                <!-- Combined Picks View Section -->
                <section class="section picks-view-section">
                <div class="picks-view-header">
                    <h2 class="section-title"><i class="fas fa-th"></i> <span id="picksViewTitle">All Player Picks</span></h2>
                    <div class="picks-view-toggle">
                        <button class="picks-toggle-btn active" data-view="matrix">
                            <i class="fas fa-table"></i> Matrix
                        </button>
                        <button class="picks-toggle-btn" data-view="distribution">
                            <i class="fas fa-chart-bar"></i> Distribution
                        </button>
                    </div>
                </div>

                <!-- Matrix View -->
                <div class="picks-view-content" id="matrixView">
                    <div class="matrix-filters">
                        <div class="matrix-filter-group">
                            <label for="matrixWeekFilter">Week:</label>
                            <select id="matrixWeekFilter">
                                <option value="all">All Weeks</option>
                            </select>
                        </div>
                        <div class="matrix-filter-group">
                            <label for="matrixGameFilter">Games:</label>
                            <select id="matrixGameFilter">
                                <option value="all">All Games</option>
                                <option value="completed">Completed Only</option>
                                <option value="upcoming">Upcoming Only</option>
                            </select>
                        </div>
                    </div>

                    <div class="picks-matrix-container">
                        <table class="picks-matrix-table" id="picksMatrixTable">
                            <thead id="matrixTableHead"></thead>
                            <tbody id="matrixTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Distribution View -->
                <div class="picks-view-content" id="distributionView" style="display: none;">
                    <div class="matrix-filters">
                        <div class="matrix-filter-group">
                            <label for="distributionWeekFilter">Week:</label>
                            <select id="distributionWeekFilter">
                                <option value="all">All Weeks</option>
                            </select>
                        </div>
                        <div class="matrix-filter-group">
                            <label for="distributionGameFilter">Games:</label>
                            <select id="distributionGameFilter">
                                <option value="all">All Games</option>
                                <option value="completed">Completed Only</option>
                                <option value="upcoming">Upcoming Only</option>
                            </select>
                        </div>
                    </div>

                    <div class="distribution-list" id="distributionList"></div>
                </div>
            </section>
            </div> <!-- end left-column-container -->

            <!-- Right Column Container -->
            <div class="right-column-container">
                <!-- Horse Race Section -->
                <section class="section horse-race-section">
                    <h2 class="section-title"><i class="fas fa-chart-line"></i> Win Progression</h2>
                    <div class="race-controls">
                        <button class="race-btn" id="showAllRace">Show All</button>
                        <button class="race-btn" id="hideAllRace">Hide All</button>
                    </div>
                    <svg id="horseRaceChart"></svg>
                    <div class="tooltip" id="raceTooltip"></div>
                    <div class="race-legend" id="raceLegend"></div>
                </section>

                <!-- What-If Analysis Section -->
                <section class="section whatif-section" id="whatifSection" style="display: none;">
                <h2 class="section-title"><i class="fas fa-wand-magic-sparkles"></i> What-If Analysis</h2>
                <p style="color: var(--text-secondary); margin-bottom: 20px;">Select winners for upcoming games to see how it would affect the standings. Click a selected team again to unset.</p>

                <!-- Summary -->
                <div class="whatif-summary">
                    <div class="whatif-summary-text">
                        <strong id="selectionCount">0</strong> of <strong id="totalGamesCount">0</strong> games selected
                    </div>
                </div>

                <!-- Two Column Layout -->
                <div class="whatif-content">
                    <!-- Left Column: Game Selection -->
                    <div class="whatif-column">
                        <div class="whatif-column-title">Select Game Winners</div>

                        <div class="whatif-controls">
                            <button class="whatif-btn secondary" id="resetWhatif">Reset All</button>
                            <button class="whatif-btn secondary" id="pickAllChalk">Pick All Chalk</button>

                            <div class="whatif-player-picker">
                                <label for="playerSelect">Copy picks from:</label>
                                <select id="playerSelect">
                                    <option value="">-- Select Player --</option>
                                </select>
                                <button class="whatif-btn" id="copyPlayerPicks">Apply</button>
                            </div>
                        </div>

                        <div class="upcoming-games" id="upcomingGames"></div>
                    </div>

                    <!-- Right Column: Projected Standings -->
                    <div class="whatif-column">
                        <div class="whatif-column-title">Standings Impact</div>

                        <div class="whatif-results" id="whatifResults">
                            <div class="whatif-placeholder">
                                <div class="whatif-placeholder-icon">📊</div>
                                <div class="whatif-placeholder-text">Select game winners to see projected standings</div>
                            </div>
                        </div>

                        <div class="whatif-results" id="whatifResultsContent" style="display: none;">
                            <div class="standings-toggle">
                                <button class="standings-toggle-btn active" data-view="projected">Projected</button>
                                <button class="standings-toggle-btn" data-view="current">Current</button>
                            </div>

                            <div class="standings-view active" id="projectedView">
                                <table class="comparison-table" id="projectedStandingsTable"></table>
                            </div>

                            <div class="standings-view" id="currentView">
                                <table class="comparison-table" id="currentStandingsTable"></table>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            </div> <!-- end right-column-container -->

        </div> <!-- end dashboard-grid -->

    </div> <!-- end dashboard-container -->

    <!-- Player Details Modal -->
    <div class="modal-overlay" id="playerModal">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <h2 class="modal-title" id="modalPlayerName"></h2>
                    <div class="modal-subtitle" id="modalPlayerStats"></div>
                </div>
                <button class="modal-close" id="closeModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="picks-list" id="modalPicksList"></div>
            </div>
        </div>
    </div>

    <!-- Matchup Tooltip -->
    <div id="matchupTooltip"></div>

    <script>
        const matchupsUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQi6KQIneboHgXLY48j6eRSCPD66Sbf4-WzSvmB7gAZv4duklJ0nluIUZZT3S68FTLp1DGcfZVHqq6n/pub?gid=1301060622&single=true&output=csv";
        const picksUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQi6KQIneboHgXLY48j6eRSCPD66Sbf4-WzSvmB7gAZv4duklJ0nluIUZZT3S68FTLp1DGcfZVHqq6n/pub?gid=881893402&single=true&output=csv";
        const playerInfoUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQi6KQIneboHgXLY48j6eRSCPD66Sbf4-WzSvmB7gAZv4duklJ0nluIUZZT3S68FTLp1DGcfZVHqq6n/pub?gid=1863176371&single=true&output=csv";

        let leaderboardData = [];
        let playerInfoMap = {}; // Map of player name -> {team, position}
        let activeFilters = {
            team: '',
            position: '',
            funkEngChallengers: false
        };
        let currentSort = 'rank';
        let currentDirection = 'asc';
        let matchupsData = {}; // Map of gameKey -> game info
        let allGames = []; // Array of all games in order
        let isExpanded = false;
        let horseRaceData = [];
        let playerColors = {};
        let pickAnalysis = {}; // Stores majority picks and distribution
        let whatifSelections = {}; // Stores what-if game winner selections
        let rawPicksData = []; // Store raw picks for what-if calculations
        let teamLineups = {}; // Map of team name (skip last name) to team members
        let scheduleFilter = 'all'; // Current schedule filter

        // Sanitize player name for use in CSS selectors
        function sanitizeName(name) {
            return name.replace(/[^a-zA-Z0-9-_]/g, '-');
        }

        // Create a unique key for a game based on Week, Date, Time, Sheet
        function createGameKey(week, date, time, sheet) {
            return `${week}_${date}_${time}_${sheet}`;
        }

        // Parse game column header to extract Week, Date, Time, Sheet
        function parseGameColumn(header) {
            // Format: "Week 3 | 11/12/2025 | 6:35 PM | Sheet 1"
            const match = header.match(/Week\s+(\d+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*Sheet\s+(\d+)/i);
            if (match) {
                return {
                    week: match[1].trim(),
                    date: match[2].trim(),
                    time: match[3].trim(),
                    sheet: match[4].trim()
                };
            }
            return null;
        }

        // Parse player info CSV and create map
        function parsePlayerInfo(rawPlayerInfo) {
            const playerMap = {};
            const teams = new Set();
            const positions = new Set();

            rawPlayerInfo.forEach(row => {
                const name = row.Name ? row.Name.trim() : '';
                const team = row.Team ? row.Team.trim() : '';
                const position = row.Position ? row.Position.trim() : '';

                if (name && name !== '') {
                    playerMap[name] = {
                        team: team,
                        position: position
                    };

                    if (team && team !== '') {
                        teams.add(team);
                    }
                    if (position && position !== '') {
                        positions.add(position);
                    }
                }
            });

            return {
                playerMap,
                teams: Array.from(teams).sort(),
                positions: Array.from(positions).sort()
            };
        }

        // Parse matchups CSV and create game map
        function parseMatchups(rawMatchups) {
            const gameMap = {};
            const gamesArray = [];

            rawMatchups.forEach((row, index) => {
                const gameKey = createGameKey(row.Week, row.Date, row.Time, row.Sheet);
                // Check if winner exists and is not just whitespace
                const winner = row.Winner && row.Winner.trim() !== '' ? row.Winner.trim() : null;

                const gameInfo = {
                    gameNumber: index + 1,
                    week: row.Week,
                    date: row.Date,
                    time: row.Time,
                    sheet: row.Sheet,
                    team1: row.Team1_Skip,
                    team2: row.Team2_Skip,
                    winner: winner,
                    gameKey: gameKey
                };
                gameMap[gameKey] = gameInfo;
                gamesArray.push(gameInfo);
            });

            return { gameMap, gamesArray };
        }

        // Analyze pick distribution for each game
        function analyzePickDistribution(rawPicks, gameMap) {
            const analysis = {};

            // Get all game column headers from picks CSV
            const headers = Object.keys(rawPicks[0] || {});
            const gameHeaders = headers.filter(h => h.includes('Week'));

            // For each game column, count picks
            gameHeaders.forEach(header => {
                const gameInfo = parseGameColumn(header);
                if (!gameInfo) return;

                const gameKey = createGameKey(gameInfo.week, gameInfo.date, gameInfo.time, gameInfo.sheet);
                const game = gameMap[gameKey];
                if (!game) return;

                const pickCounts = {};
                pickCounts[game.team1] = 0;
                pickCounts[game.team2] = 0;
                let totalPicks = 0;

                // Count picks for this game
                rawPicks.forEach(row => {
                    const pick = row[header];
                    if (pick === game.team1) {
                        pickCounts[game.team1]++;
                        totalPicks++;
                    } else if (pick === game.team2) {
                        pickCounts[game.team2]++;
                        totalPicks++;
                    }
                });

                // Calculate percentages for each team
                let team1Percentage = 0;
                let team2Percentage = 0;
                if (totalPicks > 0) {
                    team1Percentage = Math.round((pickCounts[game.team1] / totalPicks) * 100);
                    team2Percentage = Math.round((pickCounts[game.team2] / totalPicks) * 100);
                }

                // Determine chalk (majority pick)
                let chalkPick = null;
                let chalkPercentage = 50;

                if (totalPicks > 0) {
                    if (pickCounts[game.team1] > pickCounts[game.team2]) {
                        chalkPick = game.team1;
                        chalkPercentage = team1Percentage;
                    } else if (pickCounts[game.team2] > pickCounts[game.team1]) {
                        chalkPick = game.team2;
                        chalkPercentage = team2Percentage;
                    }
                }

                analysis[gameKey] = {
                    team1: game.team1,
                    team2: game.team2,
                    team1Picks: pickCounts[game.team1],
                    team2Picks: pickCounts[game.team2],
                    team1Percentage: team1Percentage,
                    team2Percentage: team2Percentage,
                    totalPicks: totalPicks,
                    chalkPick: chalkPick,
                    chalkPercentage: chalkPercentage
                };
            });

            return analysis;
        }

        // Generate consistent colors for players using a color scale
        function generatePlayerColors(playerNames) {
            const colorScale = d3.scaleOrdinal(d3.schemeTableau10.concat(d3.schemePastel1));
            const colors = {};
            playerNames.forEach((name, i) => {
                colors[name] = colorScale(i);
            });
            return colors;
        }

        // Process picks data into leaderboard format
        function processData(rawPicks, gameMap, gamesArray) {
            if (!rawPicks || rawPicks.length === 0) return [];

            const headers = Object.keys(rawPicks[0]);
            const nameHeader = headers.find(h => h.toLowerCase().includes('name'));
            const gameHeaders = headers.filter(h => h.includes('Week'));

            const players = rawPicks.map(row => {
                const name = row[nameHeader] ? row[nameHeader].trim() : '';
                if (!name) return null;

                const gameResults = [];
                let totalWins = 0;
                let currentStreak = { type: null, count: 0 };

                // Process each game column
                gameHeaders.forEach((gameHeader, headerIndex) => {
                    const gameInfo = parseGameColumn(gameHeader);
                    if (!gameInfo) return;

                    const gameKey = createGameKey(gameInfo.week, gameInfo.date, gameInfo.time, gameInfo.sheet);
                    const game = gameMap[gameKey];
                    if (!game) return;

                    const playerPick = row[gameHeader];
                    if (!playerPick) return; // Player didn't make a pick

                    // Determine result
                    let result = null;
                    if (game.winner) {
                        // Game has been played
                        result = (playerPick === game.winner) ? 'W' : 'L';
                        if (result === 'W') totalWins++;

                        // Track streaks
                        if (currentStreak.type === result) {
                            currentStreak.count++;
                        } else {
                            currentStreak = { type: result, count: 1 };
                        }
                    }
                    // If no winner yet, result stays null (game not played)

                    // Determine opponent
                    const opponent = (playerPick === game.team1) ? game.team2 : game.team1;

                    // Check if this was a contrarian pick
                    const gameAnalysis = pickAnalysis[gameKey];
                    const isContrarian = gameAnalysis && gameAnalysis.chalkPick &&
                        playerPick !== gameAnalysis.chalkPick;

                    gameResults.push({
                        game: game.gameNumber,
                        result: result,
                        cumulativeWins: totalWins,
                        cumulativeLosses: gameResults.filter(g => g.result === 'L').length,
                        isStreak: currentStreak.count >= 3 && result !== null,
                        matchup: {
                            opponent: opponent,
                            week: game.week,
                            date: game.date,
                            time: game.time,
                            sheet: game.sheet
                        },
                        pick: playerPick,
                        isContrarian: isContrarian,
                        pickAnalysis: gameAnalysis
                    });
                });

                // Filter only completed games for stats
                const completedGames = gameResults.filter(g => g.result !== null);
                const totalGames = completedGames.length;
                const totalLosses = completedGames.filter(g => g.result === 'L').length;
                const winPct = totalGames > 0 ? (totalWins / totalGames) * 100 : 0;

                // Calculate contrarian stats
                const contrarianPicks = completedGames.filter(g => g.isContrarian);
                const contrarianWins = contrarianPicks.filter(g => g.result === 'W').length;
                const contrarianTotal = contrarianPicks.length;
                const contrarianPct = totalGames > 0 ? (contrarianTotal / totalGames * 100) : 0;
                const contrarianWinRate = contrarianTotal > 0 ? (contrarianWins / contrarianTotal * 100) : 0;

                // Get recent form (last 5 completed games)
                const recentForm = completedGames.slice(-5);

                return {
                    name: name,
                    games: totalGames,
                    wins: totalWins,
                    losses: totalLosses,
                    winPct: winPct,
                    recentForm: recentForm,
                    allResults: completedGames, // Only show completed games
                    contrarianTotal: contrarianTotal,
                    contrarianWins: contrarianWins,
                    contrarianLosses: contrarianTotal - contrarianWins,
                    contrarianPct: contrarianPct,
                    contrarianWinRate: contrarianWinRate
                };
            }).filter(p => p !== null);

            // Sort by wins (descending), then by win percentage
            players.sort((a, b) => {
                if (b.wins !== a.wins) return b.wins - a.wins;
                return b.winPct - a.winPct;
            });

            // Add rank with tie handling
            let currentRank = 1;
            players.forEach((player, index) => {
                if (index > 0) {
                    const prevPlayer = players[index - 1];
                    // Check if tied with previous player (same wins and win percentage)
                    if (player.wins === prevPlayer.wins && player.winPct === prevPlayer.winPct) {
                        player.rank = prevPlayer.rank;
                    } else {
                        player.rank = index + 1;
                    }
                } else {
                    player.rank = 1;
                }
            });

            return players;
        }

        // Render Horse Race Chart
        function renderHorseRace(data) {
            const container = d3.select('#horseRaceChart');
            const tooltip = d3.select('#raceTooltip');
            const legendContainer = d3.select('#raceLegend');

            container.selectAll("*").remove();
            legendContainer.selectAll("*").remove();

            const margin = { top: 20, right: 30, bottom: 60, left: 60 };
            const containerWidth = container.node().getBoundingClientRect().width;
            const width = containerWidth - margin.left - margin.right;
            const chartHeight = window.innerWidth >= 1200 ? 450 : 400;
            const height = chartHeight - margin.top - margin.bottom;

            const svg = container
                .attr('width', containerWidth)
                .attr('height', chartHeight)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Find max games across all players
            const maxGames = d3.max(data, d => d.allResults.length);

            // Create x scale with game numbers
            const x = d3.scaleLinear()
                .domain([1, maxGames])
                .range([0, width]);

            // Create y scale with wins
            const maxWins = d3.max(data, d => d.wins);
            const y = d3.scaleLinear()
                .domain([0, maxWins])
                .range([height, 0]);

            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(maxGames).tickFormat(d => `G${d}`))
                .selectAll("text")
                .style("font-size", "11px");

            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y).ticks(maxWins));

            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 15)
                .attr('x', -height / 2)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text('Wins');

            // Add X axis label
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text('Game Number');

            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i + 1))
                .y(d => y(d.cumulativeWins));

            // Draw lines for each player
            data.forEach(player => {
                const lineData = player.allResults;
                const safeName = sanitizeName(player.name);

                svg.append('path')
                    .datum(lineData)
                    .attr('class', 'horse-race-line')
                    .attr('d', line)
                    .attr('stroke', playerColors[player.name])
                    .attr('data-player', safeName)
                    .attr('data-player-name', player.name)
                    .style('opacity', player.visible !== false ? 1 : 0.1);

                // Add dots
                svg.selectAll(`.dot-${safeName}`)
                    .data(lineData)
                    .enter()
                    .append('circle')
                    .attr('class', `horse-race-dot dot-${safeName}`)
                    .attr('cx', (d, i) => x(i + 1))
                    .attr('cy', d => y(d.cumulativeWins))
                    .attr('r', 4)
                    .attr('fill', 'white')
                    .attr('stroke', playerColors[player.name])
                    .attr('data-player', safeName)
                    .attr('data-player-name', player.name)
                    .style('opacity', player.visible !== false ? 1 : 0.1)
                    .on('mouseover', function(event, d) {
                        // Highlight line
                        d3.selectAll('.horse-race-line').classed('highlighted', false);
                        d3.select(`.horse-race-line[data-player="${safeName}"]`).classed('highlighted', true);

                        // Show tooltip
                        tooltip.html(`
                            <strong>${player.name}</strong><br>
                            Game ${d.game}: ${d.result === 'W' ? 'Win ✓' : 'Loss ✗'}<br>
                            Record: ${d.cumulativeWins}-${d.cumulativeLosses}
                        `)
                        .style('display', 'block')
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', function() {
                        d3.selectAll('.horse-race-line').classed('highlighted', false);
                        tooltip.style('display', 'none');
                    });
            });

            // Render legend
            renderRaceLegend(data);
        }

        // Render race legend
        function renderRaceLegend(data) {
            const legendContainer = d3.select('#raceLegend');
            legendContainer.selectAll("*").remove();

            // Sort by rank
            const sortedData = [...data].sort((a, b) => a.rank - b.rank);

            sortedData.forEach(player => {
                const safeName = sanitizeName(player.name);

                const item = legendContainer.append('div')
                    .attr('class', `race-legend-item ${player.visible === false ? 'hidden' : ''}`)
                    .attr('data-player', safeName)
                    .attr('data-player-name', player.name)
                    .on('click', function() {
                        player.visible = player.visible === false ? true : false;
                        renderHorseRace(horseRaceData);
                    })
                    .on('mouseover', function() {
                        d3.selectAll('.horse-race-line').classed('highlighted', false);
                        d3.select(`.horse-race-line[data-player="${safeName}"]`).classed('highlighted', true);
                    })
                    .on('mouseout', function() {
                        d3.selectAll('.horse-race-line').classed('highlighted', false);
                    });

                item.append('div')
                    .attr('class', 'race-legend-color')
                    .style('background-color', playerColors[player.name]);

                item.append('span')
                    .attr('class', 'race-legend-name')
                    .text(player.name);

                item.append('span')
                    .attr('class', 'race-legend-record')
                    .text(`${player.wins}-${player.losses}`);
            });
        }

        // Setup race control buttons
        function setupRaceControls() {
            d3.select('#showAllRace').on('click', () => {
                horseRaceData.forEach(p => p.visible = true);
                renderHorseRace(horseRaceData);
            });

            d3.select('#hideAllRace').on('click', () => {
                horseRaceData.forEach(p => p.visible = false);
                renderHorseRace(horseRaceData);
            });
        }

        // Render statistics summary
        function renderStatsSummary(data) {
            // Count actual curling games that have been played (have a winner)
            const gamesPlayed = allGames.filter(game => game.winner).length;

            // Calculate total wins and losses across all players
            const totalWins = data.reduce((sum, p) => sum + p.wins, 0);
            const totalLosses = data.reduce((sum, p) => sum + p.losses, 0);
            const totalGames = totalWins + totalLosses;

            // Calculate average win rate
            const avgWinPct = totalGames > 0 ? (totalWins / totalGames * 100) : 0;

            const totalPlayers = data.length;

            const html = `
                <div class="stat-card">
                    <div class="stat-label">Total Players</div>
                    <div class="stat-value">${totalPlayers}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Games Played</div>
                    <div class="stat-value">${gamesPlayed}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Record</div>
                    <div class="stat-value" style="font-size: 20px;">${totalWins}-${totalLosses}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg Win Rate</div>
                    <div class="stat-value">${avgWinPct.toFixed(1)}%</div>
                </div>
            `;

            document.getElementById('statsSummary').innerHTML = html;
        }

        // Render leaderboard table
        function renderLeaderboard(data) {
            const tbody = document.getElementById('leaderboardBody');
            tbody.innerHTML = '';

            data.forEach((player, playerIndex) => {
                const row = document.createElement('tr');

                // Rank with medal colors
                let rankClass = 'rank';
                if (player.rank === 1) rankClass += ' gold';
                else if (player.rank === 2) rankClass += ' silver';
                else if (player.rank === 3) rankClass += ' bronze';

                // Win percentage color
                let winPctClass = 'win-percentage';
                if (player.winPct >= 60) winPctClass += ' high';
                else if (player.winPct >= 40) winPctClass += ' medium';
                else winPctClass += ' low';

                // Show either recent form or all games based on expanded state
                const gamesToShow = isExpanded ? player.allResults : player.recentForm;
                const gameHistoryHtml = gamesToShow.map(gameData =>
                    renderGameCell(gameData, player)
                ).join('');

                row.innerHTML = `
                    <td class="center ${rankClass}">${player.rank}</td>
                    <td class="player-name" onclick="showPlayerDetails('${player.name.replace(/'/g, "\\'")}')" title="Click to view all picks">
                        ${player.name}
                        <i class="fas fa-list-ul picks-icon"></i>
                    </td>
                    <td class="center">${player.wins}</td>
                    <td class="center">${player.losses}</td>
                    <td class="center ${winPctClass}">${player.winPct.toFixed(1)}%</td>
                    <td class="center game-history-cell ${isExpanded ? 'expanded' : 'collapsed'}">
                        <div class="recent-form">${gameHistoryHtml}</div>
                    </td>
                `;

                tbody.appendChild(row);
            });
        }

        // Render a single game cell
        function renderGameCell(gameData, player) {
            const cellClass = gameData.result === 'W' ? 'win' : 'loss';

            return `<span class="form-indicator ${cellClass}"
                data-player="${player.name}"
                data-game="${gameData.game}"
                onmouseenter="showTooltip(event, '${player.name.replace(/'/g, "\\'")}', ${JSON.stringify(gameData).replace(/"/g, '&quot;')})"
                onmouseleave="hideTooltip()">${gameData.result}</span>`;
        }

        // Toggle expand/collapse for all players
        function toggleExpandCollapse() {
            isExpanded = !isExpanded;

            const expandBtn = document.getElementById('expandHeaderBtn');
            const label = document.getElementById('gameHistoryLabel');

            if (isExpanded) {
                expandBtn.classList.add('expanded');
                expandBtn.title = 'Collapse to show recent form';
                label.textContent = 'Game History';
            } else {
                expandBtn.classList.remove('expanded');
                expandBtn.title = 'Expand to show all games';
                label.textContent = 'Recent Form';
            }

            // Re-render the leaderboard with the new state
            const sortedData = sortData(leaderboardData, currentSort, currentDirection);
            renderLeaderboard(sortedData);
        }

        // Show tooltip
        function showTooltip(event, playerName, gameData) {
            const tooltip = document.getElementById('tooltip');

            // Find the game from allGames using matchup info
            let game = null;
            if (gameData.matchup) {
                game = allGames.find(g =>
                    g.week === gameData.matchup.week &&
                    g.date === gameData.matchup.date &&
                    g.time === gameData.matchup.time &&
                    g.sheet === gameData.matchup.sheet
                );
            }

            if (!game) {
                // Fallback to simple tooltip if game not found
                tooltip.innerHTML = `<div style="padding: 10px; color: var(--text-primary);">
                    <strong>${playerName}</strong><br>
                    Game ${gameData.game}: <strong>${gameData.result === 'W' ? 'Win ✓' : 'Loss ✗'}</strong><br>
                    Record: ${gameData.cumulativeWins}-${gameData.cumulativeLosses}
                </div>`;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.pageX + 15) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
                return;
            }

            // Get team lineups
            const team1Lineup = teamLineups[game.team1] || [];
            const team2Lineup = teamLineups[game.team2] || [];

            // Build tooltip with matchup structure
            const rootStyles = getComputedStyle(document.documentElement);
            const successColor = rootStyles.getPropertyValue('--success').trim();
            const successHoverColor = rootStyles.getPropertyValue('--success-hover').trim();
            const errorColor = rootStyles.getPropertyValue('--error').trim();
            const headerGradient = gameData.result === 'W'
                ? `linear-gradient(135deg, ${successColor} 0%, ${successHoverColor} 100%)`
                : `linear-gradient(135deg, ${errorColor} 0%, #e53935 100%)`;

            let tooltipContent = `
                <div class="matchup-tooltip-header" style="background: ${headerGradient};">
                    <div class="matchup-tooltip-title">
                        <strong>${playerName}</strong>: ${gameData.result === 'W' ? 'Win ✓' : 'Loss ✗'}
                    </div>
                    <div class="matchup-tooltip-info">
                        Week ${game.week} | ${game.date} | ${game.time} | Sheet ${game.sheet}
                    </div>`;

            if (gameData.pick) {
                tooltipContent += `
                    <div class="matchup-tooltip-info">
                        Picked: ${gameData.pick}
                    </div>`;
            }

            tooltipContent += `
                </div>
                <div class="matchup-tooltip-body">`;

            // Team 1
            tooltipContent += `
                <div class="tooltip-team-section">
                    <div class="tooltip-team-name ${game.winner === game.team1 ? 'winner' : ''}">
                        Team ${game.team1}${game.winner === game.team1 ? ' <i class="fas fa-trophy"></i>' : ''}
                    </div>
                    <div class="tooltip-members-row" id="formTeam1Members"></div>
                </div>
            `;

            tooltipContent += '<div class="tooltip-vs-divider">VS</div>';

            // Team 2
            tooltipContent += `
                <div class="tooltip-team-section">
                    <div class="tooltip-team-name ${game.winner === game.team2 ? 'winner' : ''}">
                        Team ${game.team2}${game.winner === game.team2 ? ' <i class="fas fa-trophy"></i>' : ''}
                    </div>
                    <div class="tooltip-members-row" id="formTeam2Members"></div>
                </div>
            `;

            tooltipContent += '</div>';
            tooltip.innerHTML = tooltipContent;

            // Add members after HTML is in DOM
            const team1Container = tooltip.querySelector('#formTeam1Members');
            const team2Container = tooltip.querySelector('#formTeam2Members');

            if (team1Lineup.length > 0) {
                team1Lineup.forEach(member => {
                    team1Container.appendChild(createTooltipMemberElement(member));
                });
            } else {
                team1Container.innerHTML = '<div style="color: var(--text-muted); font-size: 12px;">No lineup data</div>';
            }

            if (team2Lineup.length > 0) {
                team2Lineup.forEach(member => {
                    team2Container.appendChild(createTooltipMemberElement(member));
                });
            } else {
                team2Container.innerHTML = '<div style="color: var(--text-muted); font-size: 12px;">No lineup data</div>';
            }

            // Position tooltip near cursor
            tooltip.style.display = 'block';
            const tooltipRect = tooltip.getBoundingClientRect();
            const x = event.pageX + 15;
            const y = event.pageY - tooltipRect.height / 2;

            // Keep tooltip on screen
            const maxX = window.innerWidth + window.scrollX - tooltipRect.width - 20;
            const maxY = window.innerHeight + window.scrollY - tooltipRect.height - 20;

            tooltip.style.left = Math.min(x, maxX) + 'px';
            tooltip.style.top = Math.max(10, Math.min(y, maxY)) + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // Sort data
        function sortData(data, sortBy, direction) {
            const sorted = [...data];
            const dir = direction === 'asc' ? 1 : -1;

            switch(sortBy) {
                case 'name':
                    sorted.sort((a, b) => dir * a.name.localeCompare(b.name));
                    break;
                case 'wins':
                    sorted.sort((a, b) => {
                        if (a.wins !== b.wins) return dir * (b.wins - a.wins);
                        return b.winPct - a.winPct;
                    });
                    break;
                case 'losses':
                    sorted.sort((a, b) => {
                        if (a.losses !== b.losses) return dir * (b.losses - a.losses);
                        return b.wins - a.wins;
                    });
                    break;
                case 'winPct':
                    sorted.sort((a, b) => {
                        if (a.winPct !== b.winPct) return dir * (b.winPct - a.winPct);
                        return b.wins - a.wins;
                    });
                    break;
                default: // rank
                    sorted.sort((a, b) => dir * (a.rank - b.rank));
            }

            return sorted;
        }

        // Setup sortable table headers
        function setupHeaderSort() {
            const headers = document.querySelectorAll('th.sortable');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const sortBy = header.dataset.sort;

                    // Toggle direction if clicking the same header
                    if (sortBy === currentSort) {
                        currentDirection = currentDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        // Default direction based on column type
                        currentDirection = sortBy === 'name' ? 'asc' : 'desc';
                        currentSort = sortBy;
                    }

                    // Update header classes
                    headers.forEach(h => {
                        h.classList.remove('sorted-asc', 'sorted-desc');
                    });
                    header.classList.add(`sorted-${currentDirection}`);

                    // Re-render with new sort
                    const sortedData = sortData(leaderboardData, sortBy, currentDirection);
                    renderLeaderboard(sortedData);
                });
            });
        }

        // Setup expand/collapse button
        function setupExpandCollapse() {
            const expandBtn = document.getElementById('expandHeaderBtn');
            const gameHistoryHeader = document.getElementById('gameHistoryHeader');

            // Click on either the button or the header to toggle
            const toggleHandler = (e) => {
                // Prevent sorting if clicking on the game history header
                e.stopPropagation();
                toggleExpandCollapse();
            };

            expandBtn.addEventListener('click', toggleHandler);
            gameHistoryHeader.addEventListener('click', toggleHandler);
        }

        // Apply filters to leaderboard data
        function applyFilters(data) {
            const filtered = data.filter(player => {
                const playerInfo = playerInfoMap[player.name];

                // If no player info, show them by default (unless filters are active)
                if (!playerInfo) {
                    // If any filter is active, exclude players without info
                    if (activeFilters.team || activeFilters.position || activeFilters.funkEngChallengers) {
                        return false;
                    }
                    return true;
                }

                // Apply team filter
                if (activeFilters.team && playerInfo.team !== activeFilters.team) {
                    return false;
                }

                // Apply position filter
                if (activeFilters.position && playerInfo.position !== activeFilters.position) {
                    return false;
                }

                // Apply Funk-Eng Challengers filter (Lead or Second)
                if (activeFilters.funkEngChallengers) {
                    const isFunkEng = playerInfo.position === 'Lead' || playerInfo.position === 'Second';
                    if (!isFunkEng) {
                        return false;
                    }
                }

                return true;
            });

            // Log filtering results for debugging
            if (activeFilters.team || activeFilters.position || activeFilters.funkEngChallengers) {
                console.log('Filter applied:', activeFilters);
                console.log('Players with picks:', data.map(p => p.name));
                console.log('Players with team/position info:', Object.keys(playerInfoMap));
                console.log('Filtered results:', filtered.map(p => ({
                    name: p.name,
                    team: playerInfoMap[p.name]?.team,
                    position: playerInfoMap[p.name]?.position
                })));
            }

            return filtered;
        }

        // Populate filter dropdowns
        function populateFilters(teams, positions) {
            const teamFilter = document.getElementById('teamFilter');
            const positionFilter = document.getElementById('positionFilter');

            // Populate team filter
            teamFilter.innerHTML = '<option value="">All Teams</option>';
            teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                teamFilter.appendChild(option);
            });

            // Populate position filter
            positionFilter.innerHTML = '<option value="">All Positions</option>';
            positions.forEach(position => {
                const option = document.createElement('option');
                option.value = position;
                option.textContent = position;
                positionFilter.appendChild(option);
            });
        }

        // Setup filter controls
        function setupFilterControls() {
            const teamFilter = document.getElementById('teamFilter');
            const positionFilter = document.getElementById('positionFilter');
            const funkEngFilter = document.getElementById('funkEngFilter');
            const resetFilters = document.getElementById('resetFilters');

            const applyCurrentFilters = () => {
                activeFilters.team = teamFilter.value;
                activeFilters.position = positionFilter.value;
                activeFilters.funkEngChallengers = funkEngFilter.checked;

                const filteredData = applyFilters(leaderboardData);
                const sortedData = sortData(filteredData, currentSort, currentDirection);
                renderLeaderboard(sortedData);
                renderStatsSummary(sortedData);
            };

            teamFilter.addEventListener('change', applyCurrentFilters);
            positionFilter.addEventListener('change', applyCurrentFilters);
            funkEngFilter.addEventListener('change', applyCurrentFilters);

            resetFilters.addEventListener('click', () => {
                teamFilter.value = '';
                positionFilter.value = '';
                funkEngFilter.checked = false;
                activeFilters.team = '';
                activeFilters.position = '';
                activeFilters.funkEngChallengers = false;

                const sortedData = sortData(leaderboardData, currentSort, currentDirection);
                renderLeaderboard(sortedData);
                renderStatsSummary(leaderboardData);
            });
        }

        // ===== SCHEDULE AND MATCHUP FUNCTIONS =====

        // Load team lineups from team_cards.json
        async function loadTeamLineups() {
            try {
                const response = await fetch('mcc_integration/team_cards.json');
                const data = await response.json();

                // Map teams by skip's full name to handle cases where skips share last names
                data.teams.forEach(team => {
                    const skipMember = team.members.find(m => m.position === 'Skip');

                    // Map by skip's full name (e.g., "Allan Veler")
                    if (skipMember && skipMember.full_name) {
                        teamLineups[skipMember.full_name] = team.members;
                    }

                    // Also map by team_name if it exists
                    if (team.team_name && team.team_name.trim() !== '') {
                        teamLineups[team.team_name] = team.members;
                    }
                });

            } catch (error) {
                console.error('Error loading team lineups:', error);
            }
        }

        // Get sprite position for member avatar
        function getSpritePosition(memberId) {
            const spriteIndex = memberId % 25;
            const row = Math.floor(spriteIndex / 5);
            const col = spriteIndex % 5;
            const x = col * 25;
            const y = row * 25;
            return `${x}% ${y}%`;
        }

        // Create member element for tooltip
        function createTooltipMemberElement(member) {
            const div = document.createElement('div');
            div.className = 'tooltip-member';

            if (member.position === 'Skip') {
                div.classList.add('skip-member');
            }

            const positionClass = `position-${member.position.toLowerCase()}`;

            let avatarHtml = '';
            if (member.avatar) {
                avatarHtml = `
                    <div class="tooltip-avatar-wrapper">
                        <img src="${member.avatar}" alt="${member.full_name}" class="tooltip-avatar ${positionClass}">
                    </div>
                `;
            } else {
                const spritePosition = getSpritePosition(member.member_id);
                avatarHtml = `
                    <div class="tooltip-avatar-wrapper">
                        <div class="tooltip-avatar-sprite ${positionClass}"
                             style="background-position: ${spritePosition}"
                             title="${member.full_name}"></div>
                    </div>
                `;
            }

            div.innerHTML = `
                ${avatarHtml}
                <div class="tooltip-member-name">${member.first_name} ${member.last_name}</div>
                <span class="tooltip-position-badge ${positionClass}">${member.position}</span>
            `;

            return div;
        }

        // Show matchup tooltip with team lineups
        function showMatchupTooltip(event, game) {
            const tooltip = document.getElementById('matchupTooltip');
            // Match by full team name (e.g., "Allan Veler")
            const team1Lineup = teamLineups[game.team1] || [];
            const team2Lineup = teamLineups[game.team2] || [];

            let tooltipContent = `
                <div class="matchup-tooltip-header">
                    <div class="matchup-tooltip-title">Team ${game.team1} vs Team ${game.team2}</div>
                    <div class="matchup-tooltip-info">Week ${game.week} | ${game.date} | ${game.time} | Sheet ${game.sheet}</div>
                </div>
                <div class="matchup-tooltip-body">
            `;

            // Team 1
            tooltipContent += `
                <div class="tooltip-team-section">
                    <div class="tooltip-team-name ${game.winner === game.team1 ? 'winner' : ''}">
                        Team ${game.team1}${game.winner === game.team1 ? ' <i class="fas fa-trophy"></i>' : ''}
                    </div>
                    <div class="tooltip-members-row" id="team1Members"></div>
                </div>
            `;

            tooltipContent += '<div class="tooltip-vs-divider">VS</div>';

            // Team 2
            tooltipContent += `
                <div class="tooltip-team-section">
                    <div class="tooltip-team-name ${game.winner === game.team2 ? 'winner' : ''}">
                        Team ${game.team2}${game.winner === game.team2 ? ' <i class="fas fa-trophy"></i>' : ''}
                    </div>
                    <div class="tooltip-members-row" id="team2Members"></div>
                </div>
            `;

            tooltipContent += '</div>';
            tooltip.innerHTML = tooltipContent;

            // Add members after HTML is in DOM
            const team1Container = tooltip.querySelector('#team1Members');
            const team2Container = tooltip.querySelector('#team2Members');

            if (team1Lineup.length > 0) {
                team1Lineup.forEach(member => {
                    team1Container.appendChild(createTooltipMemberElement(member));
                });
            } else {
                team1Container.innerHTML = '<div style="color: var(--text-muted); font-size: 12px;">No lineup data available</div>';
            }

            if (team2Lineup.length > 0) {
                team2Lineup.forEach(member => {
                    team2Container.appendChild(createTooltipMemberElement(member));
                });
            } else {
                team2Container.innerHTML = '<div style="color: var(--text-muted); font-size: 12px;">No lineup data available</div>';
            }

            // Position tooltip near cursor
            tooltip.style.display = 'block';
            const tooltipRect = tooltip.getBoundingClientRect();
            const x = event.pageX + 15;
            const y = event.pageY - tooltipRect.height / 2;

            // Keep tooltip on screen
            const maxX = window.innerWidth + window.scrollX - tooltipRect.width - 20;
            const maxY = window.innerHeight + window.scrollY - tooltipRect.height - 20;

            tooltip.style.left = Math.min(x, maxX) + 'px';
            tooltip.style.top = Math.max(10, Math.min(y, maxY)) + 'px';
        }

        // Hide matchup tooltip
        function hideMatchupTooltip() {
            document.getElementById('matchupTooltip').style.display = 'none';
        }

        // Parse date from game (MM/DD/YYYY format) and normalize to midnight
        function parseGameDate(dateString) {
            try {
                const [month, day, year] = dateString.split('/').map(s => parseInt(s));
                const date = new Date(year, month - 1, day);
                date.setHours(0, 0, 0, 0);
                return date;
            } catch (e) {
                console.error('Error parsing date:', dateString, e);
                return null;
            }
        }

        // Get upcoming games (next game date or today's games if it's game day)
        function getUpcomingGamesFiltered() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Get all games with parsed dates
            const allGamesWithDates = allGames.map(game => ({
                ...game,
                parsedDate: parseGameDate(game.date)
            })).filter(game => game.parsedDate !== null);

            // Filter to future/today unplayed games only
            const futureUnplayedGames = allGamesWithDates.filter(game => {
                const isFuture = game.parsedDate >= today;
                const isUnplayed = !game.winner;
                return isFuture && isUnplayed;
            });

            if (futureUnplayedGames.length === 0) {
                return [];
            }

            // Sort by date
            futureUnplayedGames.sort((a, b) => a.parsedDate - b.parsedDate);

            // Get the first (next) game date
            const nextGameDate = futureUnplayedGames[0].parsedDate;

            // Filter to only games on that specific date
            const upcomingGames = futureUnplayedGames.filter(game => {
                const isSameDate = game.parsedDate.getTime() === nextGameDate.getTime();
                return isSameDate;
            });

            return upcomingGames;
        }

        // Create a compact matchup card element for full schedule
        function createMatchupCard(game) {
            const card = document.createElement('div');
            card.className = `matchup-card ${game.winner ? 'completed' : ''}`;

            // Compact single-line format: "Marcus Oldenburg vs Steve Oakeson" with winner indicator
            const team1Display = game.winner === game.team1 ? `<strong>${game.team1}</strong> <i class="fas fa-trophy"></i>` : game.team1;
            const team2Display = game.winner === game.team2 ? `<strong>${game.team2}</strong> <i class="fas fa-trophy"></i>` : game.team2;

            card.innerHTML = `
                <div class="matchup-compact-header">
                    Week ${game.week} | ${game.date} | ${game.time} | Sheet ${game.sheet}
                </div>
                <div class="matchup-compact-teams">
                    ${team1Display} <span class="compact-vs">vs</span> ${team2Display}
                </div>
            `;

            // Add hover events
            card.addEventListener('mouseenter', (e) => showMatchupTooltip(e, game));
            card.addEventListener('mouseleave', hideMatchupTooltip);
            card.addEventListener('mousemove', (e) => {
                const tooltip = document.getElementById('matchupTooltip');
                if (tooltip.style.display === 'block') {
                    const tooltipRect = tooltip.getBoundingClientRect();
                    const x = e.pageX + 15;
                    const y = e.pageY - tooltipRect.height / 2;
                    const maxX = window.innerWidth + window.scrollX - tooltipRect.width - 20;
                    const maxY = window.innerHeight + window.scrollY - tooltipRect.height - 20;
                    tooltip.style.left = Math.min(x, maxX) + 'px';
                    tooltip.style.top = Math.max(10, Math.min(y, maxY)) + 'px';
                }
            });

            return card;
        }

        // Create an expanded upcoming matchup card with team lineups
        function createUpcomingMatchupCard(game) {
            const card = document.createElement('div');
            card.className = 'upcoming-matchup-card';

            const team1Lineup = teamLineups[game.team1] || [];
            const team2Lineup = teamLineups[game.team2] || [];

            // Sanitize time to create a valid HTML ID
            const sanitizedTime = game.time.replace(/[^\w]/g, '');

            card.innerHTML = `
                <div class="upcoming-matchup-header">
                    <div class="upcoming-matchup-info">${game.time} | Sheet ${game.sheet}</div>
                </div>
                <div class="upcoming-matchup-body">
                    <div class="upcoming-team-section">
                        <div class="upcoming-team-name">${game.team1}</div>
                        <div class="upcoming-members-row" id="upcoming-team1-${game.week}-${game.sheet}-${sanitizedTime}"></div>
                    </div>
                    <div class="upcoming-vs-divider">VS</div>
                    <div class="upcoming-team-section">
                        <div class="upcoming-team-name">${game.team2}</div>
                        <div class="upcoming-members-row" id="upcoming-team2-${game.week}-${game.sheet}-${sanitizedTime}"></div>
                    </div>
                </div>
            `;

            // Add team members after card is created
            setTimeout(() => {
                const team1Container = document.getElementById(`upcoming-team1-${game.week}-${game.sheet}-${sanitizedTime}`);
                const team2Container = document.getElementById(`upcoming-team2-${game.week}-${game.sheet}-${sanitizedTime}`);

                if (team1Container && team1Lineup.length > 0) {
                    team1Lineup.forEach(member => {
                        team1Container.appendChild(createTooltipMemberElement(member));
                    });
                } else if (team1Container) {
                    team1Container.innerHTML = '<div style="color: #999; font-size: 12px;">No lineup data</div>';
                }

                if (team2Container && team2Lineup.length > 0) {
                    // Reverse order for right team to create mirror effect (Lead, Second, Vice, Skip from left to right)
                    team2Lineup.slice().reverse().forEach(member => {
                        team2Container.appendChild(createTooltipMemberElement(member));
                    });
                } else if (team2Container) {
                    team2Container.innerHTML = '<div style="color: #999; font-size: 12px;">No lineup data</div>';
                }
            }, 0);

            return card;
        }

        // Render upcoming matchups with expanded team lineup view
        function renderUpcomingMatchups() {
            const container = document.getElementById('upcomingMatchupsGrid');
            container.innerHTML = '';

            const upcomingGames = getUpcomingGamesFiltered();

            // Update header text based on number of matchups, and include week/date
            const headerElement = document.querySelector('.upcoming-section .section-title');
            if (headerElement) {
                if (upcomingGames.length === 0) {
                    headerElement.innerHTML = '<i class="fas fa-fire"></i> Upcoming Matchups';
                } else {
                    // Get week and date from first game (all upcoming games are from the same week)
                    const weekNum = upcomingGames[0].week;
                    const weekDate = upcomingGames[0].date;

                    if (upcomingGames.length === 1) {
                        headerElement.innerHTML = `<i class="fas fa-fire"></i> Upcoming Matchup - Week ${weekNum} (${weekDate})`;
                    } else {
                        headerElement.innerHTML = `<i class="fas fa-fire"></i> Upcoming Matchups - Week ${weekNum} (${weekDate})`;
                    }
                }
            }

            if (upcomingGames.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No upcoming games scheduled</div>';
                return;
            }

            upcomingGames.forEach(game => {
                container.appendChild(createUpcomingMatchupCard(game));
            });
        }

        // Render schedule matchups
        function renderSchedule() {
            const container = document.getElementById('matchupsGrid');
            container.innerHTML = '';

            // Filter games based on current filter
            let filteredGames = allGames;
            if (scheduleFilter === 'completed') {
                filteredGames = allGames.filter(game => game.winner);
            } else if (scheduleFilter === 'upcoming') {
                filteredGames = allGames.filter(game => !game.winner);
            }

            // Group games by week
            const gamesByWeek = {};
            filteredGames.forEach(game => {
                if (!gamesByWeek[game.week]) {
                    gamesByWeek[game.week] = [];
                }
                gamesByWeek[game.week].push(game);
            });

            // Sort weeks numerically
            const weeks = Object.keys(gamesByWeek).map(Number).sort((a, b) => a - b);

            // Render each week group
            weeks.forEach(week => {
                const weekGroup = document.createElement('div');
                weekGroup.className = 'week-group';

                const weekHeader = document.createElement('div');
                weekHeader.className = 'week-header';
                weekHeader.textContent = `Week ${week}`;
                weekGroup.appendChild(weekHeader);

                const weekGamesContainer = document.createElement('div');
                weekGamesContainer.className = 'week-games';

                gamesByWeek[week].forEach(game => {
                    weekGamesContainer.appendChild(createMatchupCard(game));
                });

                weekGroup.appendChild(weekGamesContainer);
                container.appendChild(weekGroup);
            });
        }

        // Setup expand/collapse button for schedule
        function setupExpandSchedule() {
            const expandBtn = document.getElementById('expandScheduleBtn');
            const fullScheduleSection = document.getElementById('fullScheduleSection');
            const expandText = document.getElementById('expandScheduleText');
            const expandIcon = document.getElementById('expandScheduleIcon');

            expandBtn.addEventListener('click', () => {
                const isExpanded = fullScheduleSection.style.display !== 'none';

                if (isExpanded) {
                    // Collapse
                    fullScheduleSection.style.display = 'none';
                    expandText.textContent = 'Show Full Schedule';
                    expandBtn.classList.remove('expanded');
                } else {
                    // Expand
                    fullScheduleSection.style.display = 'block';
                    expandText.textContent = 'Hide Full Schedule';
                    expandBtn.classList.add('expanded');
                }
            });
        }

        // Setup schedule filter buttons
        function setupScheduleFilters() {
            const filterButtons = document.querySelectorAll('.schedule-filter-btn');
            filterButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update active button
                    filterButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update filter and re-render
                    scheduleFilter = btn.dataset.filter;
                    renderSchedule();
                });
            });
        }

        // ===== WHAT-IF ANALYSIS FUNCTIONS =====

        // Get upcoming (unplayed) games
        function getUpcomingGames() {
            return allGames.filter(game => !game.winner);
        }

        // Render what-if analysis panel
        function renderWhatIfPanel() {
            const upcomingGames = getUpcomingGames();

            if (upcomingGames.length === 0) {
                document.getElementById('whatifSection').style.display = 'none';
                return;
            }

            document.getElementById('whatifSection').style.display = 'block';

            // Update summary
            const selectionCount = Object.keys(whatifSelections).length;
            document.getElementById('selectionCount').textContent = selectionCount;
            document.getElementById('totalGamesCount').textContent = upcomingGames.length;

            const container = document.getElementById('upcomingGames');
            container.innerHTML = '';

            upcomingGames.forEach(game => {
                const analysis = pickAnalysis[game.gameKey];
                const card = document.createElement('div');
                card.className = 'game-card';

                const team1IsChalk = analysis && analysis.chalkPick === game.team1;
                const team2IsChalk = analysis && analysis.chalkPick === game.team2;

                card.innerHTML = `
                    <div class="game-card-header">
                        Week ${game.week} | ${game.date} | ${game.time} | Sheet ${game.sheet}
                    </div>
                    <div class="game-matchup">
                        <div class="team-option ${team1IsChalk ? 'chalk' : ''} ${whatifSelections[game.gameKey] === game.team1 ? 'selected' : ''}"
                             data-gamekey="${game.gameKey}" data-team="${game.team1}">
                            <input type="radio" name="game-${game.gameKey}" value="${game.team1}"
                                   ${whatifSelections[game.gameKey] === game.team1 ? 'checked' : ''}>
                            <span class="team-name">${game.team1}</span>
                            ${analysis ? `<span class="pick-count">${analysis.team1Picks} picks</span>` : ''}
                        </div>
                        <div class="team-option ${team2IsChalk ? 'chalk' : ''} ${whatifSelections[game.gameKey] === game.team2 ? 'selected' : ''}"
                             data-gamekey="${game.gameKey}" data-team="${game.team2}">
                            <input type="radio" name="game-${game.gameKey}" value="${game.team2}"
                                   ${whatifSelections[game.gameKey] === game.team2 ? 'checked' : ''}>
                            <span class="team-name">${game.team2}</span>
                            ${analysis ? `<span class="pick-count">${analysis.team2Picks} picks</span>` : ''}
                        </div>
                    </div>
                `;

                container.appendChild(card);
            });

            // Add click handlers
            document.querySelectorAll('.team-option').forEach(option => {
                option.addEventListener('click', function() {
                    const gameKey = this.dataset.gamekey;
                    const team = this.dataset.team;
                    selectWhatIfWinner(gameKey, team);
                });
            });
        }

        // Handle what-if winner selection (toggle if same team clicked)
        function selectWhatIfWinner(gameKey, team) {
            // Toggle: if clicking the already selected team, unset it
            if (whatifSelections[gameKey] === team) {
                delete whatifSelections[gameKey];
            } else {
                whatifSelections[gameKey] = team;
            }
            renderWhatIfPanel(); // Re-render to update UI
            updateProjectedStandings();
        }

        // Get player's picks for upcoming games
        function getPlayerPicks(playerName) {
            const playerRow = rawPicksData.find(row => {
                const headers = Object.keys(row);
                const nameHeader = headers.find(h => h.toLowerCase().includes('name'));
                const rowName = row[nameHeader] ? row[nameHeader].trim() : '';
                return rowName === playerName;
            });

            if (!playerRow) return {};

            const picks = {};
            const upcomingGames = getUpcomingGames();
            const headers = Object.keys(playerRow);

            upcomingGames.forEach(game => {
                // Find the matching header for this game
                headers.forEach(header => {
                    const gameInfo = parseGameColumn(header);
                    if (gameInfo) {
                        const gameKey = createGameKey(gameInfo.week, gameInfo.date, gameInfo.time, gameInfo.sheet);
                        if (gameKey === game.gameKey) {
                            const pick = playerRow[header];
                            if (pick) {
                                picks[gameKey] = pick;
                            }
                        }
                    }
                });
            });

            return picks;
        }

        // Calculate projected standings based on what-if selections
        function calculateProjectedStandings() {
            // Create a copy of matchups data with what-if winners applied
            const whatifGameMap = {};
            Object.keys(matchupsData).forEach(key => {
                whatifGameMap[key] = { ...matchupsData[key] };
                if (whatifSelections[key]) {
                    whatifGameMap[key].winner = whatifSelections[key];
                }
            });

            // Recalculate standings with what-if results
            return processData(rawPicksData, whatifGameMap, allGames);
        }

        // Update projected standings display
        function updateProjectedStandings() {
            const hasSelections = Object.keys(whatifSelections).length > 0;

            if (!hasSelections) {
                // Show placeholder, hide results
                document.getElementById('whatifResults').style.display = 'flex';
                document.getElementById('whatifResultsContent').style.display = 'none';
                return;
            }

            // Hide placeholder, show results
            document.getElementById('whatifResults').style.display = 'none';
            document.getElementById('whatifResultsContent').style.display = 'flex';

            const projectedData = calculateProjectedStandings();

            // Render projected standings first (with comparison to current)
            renderComparisonTable('projectedStandingsTable', projectedData, leaderboardData);
            // Render current standings (without comparison)
            renderComparisonTable('currentStandingsTable', leaderboardData, null);
        }

        // Render comparison table
        function renderComparisonTable(tableId, data, compareData) {
            const table = document.getElementById(tableId);

            let html = `
                <thead>
                    <tr>
                        <th class="center">Rank</th>
                        <th>Player</th>
                        <th class="center">W</th>
                        <th class="center">L</th>
                        <th class="center">Win %</th>
                    </tr>
                </thead>
                <tbody>
            `;

            data.forEach((player, index) => {
                let rankClass = 'rank';
                if (player.rank === 1) rankClass += ' gold';
                else if (player.rank === 2) rankClass += ' silver';
                else if (player.rank === 3) rankClass += ' bronze';

                let winPctClass = 'win-percentage';
                if (player.winPct >= 60) winPctClass += ' high';
                else if (player.winPct >= 40) winPctClass += ' medium';
                else winPctClass += ' low';

                // Calculate rank change if comparing
                let rankChange = '';
                if (compareData) {
                    const oldPlayer = compareData.find(p => p.name === player.name);
                    if (oldPlayer) {
                        const change = oldPlayer.rank - player.rank;
                        if (change > 0) {
                            rankChange = `<span class="rank-change up">▲${change}</span>`;
                        } else if (change < 0) {
                            rankChange = `<span class="rank-change down">▼${Math.abs(change)}</span>`;
                        } else {
                            rankChange = `<span class="rank-change same">―</span>`;
                        }
                    }
                }

                html += `
                    <tr>
                        <td class="center ${rankClass}">${player.rank}${rankChange}</td>
                        <td class="player-name">${player.name}</td>
                        <td class="center">${player.wins}</td>
                        <td class="center">${player.losses}</td>
                        <td class="center ${winPctClass}">${player.winPct.toFixed(1)}%</td>
                    </tr>
                `;
            });

            html += '</tbody>';
            table.innerHTML = html;
        }

        // Setup what-if controls
        function setupWhatIfControls() {
            // Populate player dropdown
            const playerSelect = document.getElementById('playerSelect');
            playerSelect.innerHTML = '<option value="">-- Select Player --</option>';
            leaderboardData.forEach(player => {
                const option = document.createElement('option');
                option.value = player.name;
                option.textContent = player.name;
                playerSelect.appendChild(option);
            });

            // Toggle between projected and current standings
            document.querySelectorAll('.standings-toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const view = btn.dataset.view;

                    // Update button states
                    document.querySelectorAll('.standings-toggle-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    btn.classList.add('active');

                    // Update view visibility
                    document.querySelectorAll('.standings-view').forEach(v => {
                        v.classList.remove('active');
                    });
                    if (view === 'projected') {
                        document.getElementById('projectedView').classList.add('active');
                    } else {
                        document.getElementById('currentView').classList.add('active');
                    }
                });
            });

            // Reset all selections
            document.getElementById('resetWhatif').addEventListener('click', () => {
                whatifSelections = {};
                renderWhatIfPanel();
                updateProjectedStandings();
            });

            // Pick all chalk
            document.getElementById('pickAllChalk').addEventListener('click', () => {
                const upcomingGames = getUpcomingGames();
                upcomingGames.forEach(game => {
                    const analysis = pickAnalysis[game.gameKey];
                    if (analysis && analysis.chalkPick) {
                        whatifSelections[game.gameKey] = analysis.chalkPick;
                    }
                });
                renderWhatIfPanel();
                updateProjectedStandings();
            });

            // Copy player picks
            document.getElementById('copyPlayerPicks').addEventListener('click', () => {
                const selectedPlayer = playerSelect.value;
                if (!selectedPlayer) {
                    alert('Please select a player first');
                    return;
                }

                const playerPicks = getPlayerPicks(selectedPlayer);
                // Apply all of this player's picks to whatif selections
                Object.keys(playerPicks).forEach(gameKey => {
                    whatifSelections[gameKey] = playerPicks[gameKey];
                });

                renderWhatIfPanel();
                updateProjectedStandings();
            });
        }

        // Load and display data
        // ===== PLAYER DETAILS MODAL =====
        window.showPlayerDetails = function(playerName) {
            // Find player data
            const player = leaderboardData.find(p => p.name === playerName);
            if (!player) return;

            // Get all picks for this player from rawPicksData
            const headers = Object.keys(rawPicksData[0]);
            const nameHeader = headers.find(h => h.toLowerCase().includes('name'));
            const playerRow = rawPicksData.find(row => {
                const rowName = row[nameHeader] ? row[nameHeader].trim() : '';
                return rowName === playerName;
            });
            if (!playerRow) return;

            // Get all game headers
            const gameHeaders = headers.filter(h => h.includes('Week'));

            // Build picks data with full game information
            const allPicks = [];
            gameHeaders.forEach(gameHeader => {
                const gameInfo = parseGameColumn(gameHeader);
                if (!gameInfo) return;

                const gameKey = createGameKey(gameInfo.week, gameInfo.date, gameInfo.time, gameInfo.sheet);
                const game = matchupsData[gameKey];
                if (!game) return;

                const playerPick = playerRow[gameHeader];
                if (!playerPick) return;

                let result = null;
                if (game.winner) {
                    result = (playerPick === game.winner) ? 'W' : 'L';
                }

                allPicks.push({
                    gameNumber: game.gameNumber,
                    week: game.week,
                    date: game.date,
                    time: game.time,
                    sheet: game.sheet,
                    team1: game.team1,
                    team2: game.team2,
                    pick: playerPick,
                    winner: game.winner,
                    result: result
                });
            });

            // Sort by game number
            allPicks.sort((a, b) => a.gameNumber - b.gameNumber);

            // Update modal content
            document.getElementById('modalPlayerName').textContent = playerName;
            document.getElementById('modalPlayerStats').textContent =
                `${player.wins}-${player.losses} (${player.winPct.toFixed(1)}%) • Rank: ${player.rank}`;

            const picksList = document.getElementById('modalPicksList');
            picksList.innerHTML = '';

            allPicks.forEach(pick => {
                const pickItem = document.createElement('div');
                let statusClass = 'pick-pending';
                if (pick.result === 'W') statusClass = 'pick-win';
                else if (pick.result === 'L') statusClass = 'pick-loss';

                pickItem.className = `pick-item ${statusClass}`;

                let resultBadge = '';
                if (pick.result === 'W') {
                    resultBadge = '<span class="pick-result-badge win">WIN</span>';
                } else if (pick.result === 'L') {
                    resultBadge = '<span class="pick-result-badge loss">LOSS</span>';
                } else {
                    resultBadge = '<span class="pick-result-badge pending">TBD</span>';
                }

                pickItem.innerHTML = `
                    <div class="pick-game-number">Game ${pick.gameNumber}</div>
                    <div class="pick-details">
                        <div class="pick-matchup">
                            <span class="pick-matchup-teams">${pick.team1} vs ${pick.team2}</span>
                        </div>
                        <div class="pick-info">
                            Week ${pick.week} • ${pick.date} • ${pick.time} • Sheet ${pick.sheet}
                        </div>
                        <div class="pick-choice">
                            <span class="pick-choice-label">Picked:</span>
                            <span class="pick-choice-team">${pick.pick}</span>
                        </div>
                        ${pick.winner ? `<div class="pick-info">Winner: <strong>${pick.winner}</strong></div>` : ''}
                    </div>
                    <div class="pick-result">
                        ${resultBadge}
                    </div>
                `;

                picksList.appendChild(pickItem);
            });

            // Show modal
            document.getElementById('playerModal').classList.add('active');
        }

        function closePlayerModal() {
            document.getElementById('playerModal').classList.remove('active');
        }

        // Close modal on overlay click
        document.getElementById('playerModal').addEventListener('click', (e) => {
            if (e.target.id === 'playerModal') {
                closePlayerModal();
            }
        });

        document.getElementById('closeModal').addEventListener('click', closePlayerModal);

        // ===== PICK DISTRIBUTION VIEW =====
        let distributionFilters = {
            week: 'all',
            gameStatus: 'all'
        };

        function renderPickDistribution() {
            const container = document.getElementById('distributionList');
            container.innerHTML = '';

            // Get all games in order
            let filteredGames = [...allGames];

            // Apply filters
            if (distributionFilters.week !== 'all') {
                filteredGames = filteredGames.filter(g => g.week == distributionFilters.week);
            }
            if (distributionFilters.gameStatus === 'completed') {
                filteredGames = filteredGames.filter(g => g.winner !== null);
            } else if (distributionFilters.gameStatus === 'upcoming') {
                filteredGames = filteredGames.filter(g => g.winner === null);
            }

            // Render each game's distribution
            filteredGames.forEach(game => {
                const analysis = pickAnalysis[game.gameKey];
                if (!analysis) return;

                const item = document.createElement('div');
                item.className = 'distribution-item';

                const team1Pct = analysis.team1Percentage || 0;
                const team2Pct = analysis.team2Percentage || 0;
                const team1Count = analysis.team1Picks || 0;
                const team2Count = analysis.team2Picks || 0;
                const totalPicks = team1Count + team2Count;

                // Determine winner badge
                let winnerBadge = '';
                if (game.winner) {
                    winnerBadge = `<span class="distribution-winner-badge">
                        <i class="fas fa-trophy"></i> Winner: ${game.winner}
                    </span>`;
                }

                item.innerHTML = `
                    <div class="distribution-header">
                        <div class="distribution-game-info">
                            Week ${game.week} • ${game.date} • ${game.time} • Sheet ${game.sheet}
                        </div>
                        ${winnerBadge}
                    </div>
                    <div class="distribution-matchup">${game.team1} vs ${game.team2}</div>
                    <div class="distribution-bar-container">
                        <div class="distribution-bar team1" style="width: ${team1Pct}%" title="${game.team1}: ${team1Count} picks (${team1Pct}%)">
                            ${team1Pct >= 15 ? team1Pct + '%' : ''}
                        </div>
                        <div class="distribution-bar team2" style="width: ${team2Pct}%" title="${game.team2}: ${team2Count} picks (${team2Pct}%)">
                            ${team2Pct >= 15 ? team2Pct + '%' : ''}
                        </div>
                    </div>
                    <div class="distribution-labels">
                        <div class="distribution-label">
                            <div class="distribution-label-color team1"></div>
                            <span class="distribution-label-text">${game.team1}</span>
                            <span class="distribution-label-count">${team1Count} picks (${team1Pct}%)</span>
                        </div>
                        <div class="distribution-label">
                            <div class="distribution-label-color team2"></div>
                            <span class="distribution-label-text">${game.team2}</span>
                            <span class="distribution-label-count">${team2Count} picks (${team2Pct}%)</span>
                        </div>
                    </div>
                `;

                container.appendChild(item);
            });

            if (filteredGames.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 40px;">No games match the selected filters.</p>';
            }
        }

        function setupCombinedPicksView() {
            const matrixView = document.getElementById('matrixView');
            const distributionView = document.getElementById('distributionView');
            const toggleButtons = document.querySelectorAll('.picks-toggle-btn');
            const title = document.getElementById('picksViewTitle');

            // Toggle between views
            toggleButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const view = btn.dataset.view;

                    // Update button states
                    toggleButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Show/hide views
                    if (view === 'matrix') {
                        matrixView.style.display = 'block';
                        distributionView.style.display = 'none';
                        title.textContent = 'All Player Picks';
                    } else {
                        matrixView.style.display = 'none';
                        distributionView.style.display = 'block';
                        title.textContent = 'Pick Distribution';

                        // Render distribution if not already done
                        const container = document.getElementById('distributionList');
                        if (container.innerHTML === '') {
                            renderPickDistribution();
                        }
                    }
                });
            });

            // Setup matrix filters
            const matrixWeekFilter = document.getElementById('matrixWeekFilter');
            const weeks = [...new Set(allGames.map(g => g.week))].sort((a, b) => a - b);
            weeks.forEach(week => {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                matrixWeekFilter.appendChild(option);
            });

            matrixWeekFilter.addEventListener('change', (e) => {
                matrixFilters.week = e.target.value;
                renderPicksMatrix();
            });

            document.getElementById('matrixGameFilter').addEventListener('change', (e) => {
                matrixFilters.gameStatus = e.target.value;
                renderPicksMatrix();
            });

            // Setup distribution filters
            const distributionWeekFilter = document.getElementById('distributionWeekFilter');
            weeks.forEach(week => {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                distributionWeekFilter.appendChild(option);
            });

            distributionWeekFilter.addEventListener('change', (e) => {
                distributionFilters.week = e.target.value;
                renderPickDistribution();
            });

            document.getElementById('distributionGameFilter').addEventListener('change', (e) => {
                distributionFilters.gameStatus = e.target.value;
                renderPickDistribution();
            });

            // Render initial matrix view
            renderPicksMatrix();
        }

        // ===== PICKS MATRIX VIEW =====
        let matrixFilters = {
            week: 'all',
            gameStatus: 'all'
        };

        function createPieChart(team1Pct, team2Pct) {
            const size = 50;
            const radius = 20;
            const cx = size / 2;
            const cy = size / 2;

            // Brand colors for contrast
            const rootStyles = getComputedStyle(document.documentElement);
            const team1Color = rootStyles.getPropertyValue('--mcc-dark-1').trim();
            const team2Color = rootStyles.getPropertyValue('--mcc-gold-1').trim();

            // Calculate the end angle for team1 (starting at top, going clockwise)
            const team1Angle = (team1Pct / 100) * 360;

            // Convert to radians and calculate end point
            const team1Radians = ((team1Angle - 90) * Math.PI) / 180;
            const team1X = cx + radius * Math.cos(team1Radians);
            const team1Y = cy + radius * Math.sin(team1Radians);

            // Determine if we need the large arc flag
            const largeArc1 = team1Pct > 50 ? 1 : 0;
            const largeArc2 = team2Pct > 50 ? 1 : 0;

            let svg = `<svg class="matrix-header-pie" viewBox="0 0 ${size} ${size}">`;

            if (team1Pct === 0) {
                // All team2
                svg += `<circle cx="${cx}" cy="${cy}" r="${radius}" fill="${team2Color}"/>`;
            } else if (team2Pct === 0) {
                // All team1
                svg += `<circle cx="${cx}" cy="${cy}" r="${radius}" fill="${team1Color}"/>`;
            } else if (team1Pct === 50) {
                // Perfect split - show half and half
                svg += `
                    <path d="M ${cx},${cy} L ${cx},${cy - radius} A ${radius},${radius} 0 0 1 ${cx},${cy + radius} Z" fill="${team1Color}"/>
                    <path d="M ${cx},${cy} L ${cx},${cy + radius} A ${radius},${radius} 0 0 1 ${cx},${cy - radius} Z" fill="${team2Color}"/>
                `;
            } else {
                // Team1 slice
                svg += `
                    <path d="M ${cx},${cy} L ${cx},${cy - radius} A ${radius},${radius} 0 ${largeArc1} 1 ${team1X},${team1Y} Z"
                          fill="${team1Color}"/>
                `;

                // Team2 slice - fills the rest
                svg += `
                    <path d="M ${cx},${cy} L ${team1X},${team1Y} A ${radius},${radius} 0 ${largeArc2} 1 ${cx},${cy - radius} Z"
                          fill="${team2Color}"/>
                `;
            }

            svg += '</svg>';
            return svg;
        }

        function renderPicksMatrix() {
            const thead = document.getElementById('matrixTableHead');
            const tbody = document.getElementById('matrixTableBody');

            // Get all game headers
            const headers = Object.keys(rawPicksData[0]);
            const gameHeaders = headers.filter(h => h.includes('Week'));

            // Build game list with full info
            const games = [];
            gameHeaders.forEach(gameHeader => {
                const gameInfo = parseGameColumn(gameHeader);
                if (!gameInfo) return;

                const gameKey = createGameKey(gameInfo.week, gameInfo.date, gameInfo.time, gameInfo.sheet);
                const game = matchupsData[gameKey];
                if (!game) return;

                games.push({
                    header: gameHeader,
                    ...game
                });
            });

            // Sort by game number
            games.sort((a, b) => a.gameNumber - b.gameNumber);

            // Apply filters
            let filteredGames = games;
            if (matrixFilters.week !== 'all') {
                filteredGames = filteredGames.filter(g => g.week == matrixFilters.week);
            }
            if (matrixFilters.gameStatus === 'completed') {
                filteredGames = filteredGames.filter(g => g.winner !== null);
            } else if (matrixFilters.gameStatus === 'upcoming') {
                filteredGames = filteredGames.filter(g => g.winner === null);
            }

            // Build header row
            thead.innerHTML = '';
            const headerRow = document.createElement('tr');

            // Player name column
            const playerHeader = document.createElement('th');
            playerHeader.className = 'player-col';
            playerHeader.textContent = 'Player';
            headerRow.appendChild(playerHeader);

            // Group games by week for header
            const weekGroups = {};
            filteredGames.forEach(game => {
                if (!weekGroups[game.week]) {
                    weekGroups[game.week] = [];
                }
                weekGroups[game.week].push(game);
            });

            // Add game columns
            filteredGames.forEach(game => {
                const gameHeader = document.createElement('th');

                // Get pick analysis for this game
                const analysis = pickAnalysis[game.gameKey];
                const team1Pct = analysis ? (analysis.team1Percentage || 0) : 50;
                const team2Pct = analysis ? (analysis.team2Percentage || 0) : 50;
                const team1Count = analysis ? (analysis.team1Picks || 0) : 0;
                const team2Count = analysis ? (analysis.team2Picks || 0) : 0;

                // Create pie chart
                const pieChartSVG = createPieChart(team1Pct, team2Pct);

                gameHeader.innerHTML = `
                    <div class="matrix-header-content">
                        <div class="matrix-header-pie-wrapper" style="position: relative;">
                            ${pieChartSVG}
                            <div class="pie-tooltip" id="pieTooltip-${game.gameNumber}">
                                <div style="color: var(--mcc-light-2); font-weight: 600;">${game.team1}: ${team1Pct}%</div>
                                <div style="color: var(--gold); font-weight: 600;">${game.team2}: ${team2Pct}%</div>
                            </div>
                        </div>
                        <div class="matrix-header-info">
                            <div style="font-weight: bold;">Week ${game.week}</div>
                            <div style="font-size: 10px; margin-top: 2px;">${game.date}</div>
                            <div style="font-size: 10px;">${game.time}</div>
                            <div style="font-size: 10px; margin-top: 5px; font-weight: 600; line-height: 1.5;">
                                <div style="color: var(--mcc-dark-1);">${game.team1} (${team1Pct}%)</div>
                                <div style="color: var(--mcc-gold-1);">${game.team2} (${team2Pct}%)</div>
                            </div>
                        </div>
                    </div>
                `;

                headerRow.appendChild(gameHeader);

                // Add hover event to pie chart
                const pieChart = gameHeader.querySelector('.matrix-header-pie');
                const tooltip = gameHeader.querySelector(`#pieTooltip-${game.gameNumber}`);

                if (pieChart && tooltip) {
                    pieChart.addEventListener('mouseenter', (e) => {
                        tooltip.classList.add('active');
                        const rect = pieChart.getBoundingClientRect();
                        tooltip.style.left = '50%';
                        tooltip.style.transform = 'translateX(-50%)';
                        tooltip.style.top = '-35px';
                    });

                    pieChart.addEventListener('mouseleave', () => {
                        tooltip.classList.remove('active');
                    });
                }
            });

            thead.appendChild(headerRow);

            // Build body rows
            tbody.innerHTML = '';

            // Get name header for finding player rows
            const allHeaders = Object.keys(rawPicksData[0]);
            const nameHeader = allHeaders.find(h => h.toLowerCase().includes('name'));

            leaderboardData.forEach(player => {
                const row = document.createElement('tr');

                // Player name cell
                const nameCell = document.createElement('td');
                nameCell.className = 'player-col';
                nameCell.textContent = player.name;
                nameCell.style.cursor = 'pointer';
                nameCell.onclick = () => showPlayerDetails(player.name);
                row.appendChild(nameCell);

                // Find player row in raw data
                const playerRow = rawPicksData.find(r => {
                    const rowName = r[nameHeader] ? r[nameHeader].trim() : '';
                    return rowName === player.name;
                });

                // Add pick cells
                filteredGames.forEach(game => {
                    const pickCell = document.createElement('td');

                    if (playerRow && playerRow[game.header]) {
                        const pick = playerRow[game.header];
                        const pickDiv = document.createElement('div');
                        pickDiv.className = 'matrix-pick-cell';

                        // Determine result class
                        let resultClass = 'pending';
                        if (game.winner) {
                            resultClass = (pick === game.winner) ? 'win' : 'loss';
                        }
                        pickDiv.classList.add(resultClass);

                        pickDiv.textContent = pick;
                        pickCell.appendChild(pickDiv);
                    } else {
                        pickCell.textContent = '-';
                        pickCell.style.color = 'var(--text-disabled)';
                    }

                    row.appendChild(pickCell);
                });

                tbody.appendChild(row);
            });
        }

        Promise.all([
            d3.csv(matchupsUrl),
            d3.csv(picksUrl),
            d3.csv(playerInfoUrl)
        ]).then(([matchups, picks, playerInfo]) => {
            // Store raw picks for what-if calculations
            rawPicksData = picks;

            // Parse player info CSV
            const { playerMap, teams, positions } = parsePlayerInfo(playerInfo);
            playerInfoMap = playerMap;

            // Parse matchups CSV
            const { gameMap, gamesArray } = parseMatchups(matchups);
            matchupsData = gameMap;
            allGames = gamesArray;

            // Analyze pick distribution to identify chalk/contrarian picks
            pickAnalysis = analyzePickDistribution(picks, gameMap);

            // Process picks data to create leaderboard
            leaderboardData = processData(picks, gameMap, gamesArray);
            horseRaceData = leaderboardData; // Same data for horse race

            // Generate consistent colors for all players
            playerColors = generatePlayerColors(leaderboardData.map(p => p.name));

            // Hide loading, show dashboard
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('dashboardGrid').style.display = 'grid';

            // Populate and setup filters
            populateFilters(teams, positions);
            setupFilterControls();

            // Render everything
            renderHorseRace(horseRaceData);
            renderStatsSummary(leaderboardData);
            renderLeaderboard(leaderboardData);
            setupHeaderSort();
            setupExpandCollapse();
            setupRaceControls();

            // Setup what-if analysis
            renderWhatIfPanel();
            setupWhatIfControls();

            // Setup combined picks view controls
            setupCombinedPicksView();

            // Load team lineups and setup schedule
            loadTeamLineups().then(() => {
                renderUpcomingMatchups();
                renderSchedule();
                setupScheduleFilters();
                setupExpandSchedule();
            }).catch(err => {
                console.error('Error in loadTeamLineups:', err);
            });

        }).catch(error => {
            console.error("Error fetching or parsing CSV:", error);
            document.getElementById('loadingMessage').style.display = 'none';
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = `Error loading leaderboard data: ${error.message}`;
            errorDiv.style.display = 'block';
        });
    </script>
</body>
</html>
